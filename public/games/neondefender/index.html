<!--
    NEON DEFENDER
    ---------------------------------------------------
    Version: 1.1.3 (Server-side Gemini Proxy)
    Last Updated: 2026-01-28
    
    Changelog:
    - Routed mission generation through /api/proxy to keep Gemini key server-side.
    - Injected env config via Astro wrapper for Gemini/Firebase keys.
    - Added config script hook to load runtime keys safely.
    - Routed Neon Defender through /games/neondefender for config injection.
    - Improved mobile UI firebutton placement and size.
    - Forced single-player mode on mobile and hid 2-player option.
    - Moved pause button under lives and improved touch button layering.
    - Added dedicated mobile fire button and horizontal mobile arsenal HUD.
    - Added mobile fire button to prevent accidental overheat while dragging.
    - Reworked mobile arsenal UI to a horizontal bottom layout.
    - Improved touch handling for movement without auto-shooting.
    ---------------------------------------------------
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Space Defender AI</title>
    <script id="neon-config" type="application/json">{}</script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px #0ff;
            align-items: flex-start;
            pointer-events: auto;
        }

        .hud-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
            text-align: left;
        }

        .hud-right {
            display: flex;
            flex-direction: column;
            gap: 5px;
            text-align: right;
        }

        #bossTimer {
            color: #f55;
            font-size: 16px;
        }

        .hud-center {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        /* Vertical Arsenal System Styles */
        .arsenal-panel {
            position: absolute;
            bottom: 20px;
            width: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0ff;
            border-radius: 10px;
            padding: 10px;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
            display: flex;
            flex-direction: row;
            gap: 10px;
            align-items: center;
        }

        #arsenal-panel-p1 {
            right: 20px;
        }

        #arsenal-panel-p2 {
            left: 20px;
            border-color: #fa0;
        }

        .arsenal-player {
            display: flex;
            flex-direction: row;
            gap: 10px;
            align-items: center;
        }

        .arsenal-label {
            font-size: 12px;
            color: #0ff;
            text-align: center;
            margin-bottom: 6px;
        }
        
        #arsenal-panel-p2 .arsenal-label {
            color: #fa0;
        }

        .arsenal-title {
            display: none; /* Hide title to save space */
        }

        .heat-container {
            display: flex;
            flex-direction: column-reverse; /* Bottom up */
            align-items: center;
            height: 200px;
            width: 30px;
        }

        .heat-label {
            font-size: 10px;
            color: #aaa;
            margin-top: 5px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
        }

        .heat-bar-bg {
            width: 12px;
            height: 100%;
            background: #333;
            border: 1px solid #555;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }

        #heat-bar-fill-p1,
        #heat-bar-fill-p2 {
            width: 100%;
            height: 0%;
            background: #0f0;
            position: absolute;
            bottom: 0;
            left: 0;
            transition: height 0.1s linear, width 0.1s linear, background-color 0.2s;
        }

        .modules-grid {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .module-icon {
            width: 36px;
            height: 36px;
            border: 1px solid #444;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #444;
            border-radius: 5px;
            position: relative;
            transition: all 0.2s;
        }

        .module-active {
            border-color: #fff;
            color: #fff;
            text-shadow: 0 0 5px currentColor;
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
            box-shadow: 0 0 8px rgba(255,255,255,0.3);
        }
        
        .weapon-active-spread {
            border-color: #0ff;
            color: #0ff;
            box-shadow: 0 0 10px #0ff;
        }
        
        .weapon-active-laser {
            border-color: #0f0;
            color: #0f0;
            box-shadow: 0 0 10px #0f0;
        }

        .module-sub {
            position: absolute;
            bottom: 1px;
            right: 2px;
            font-size: 9px;
            font-weight: bold;
        }

        /* --- */

        .level-up-msg {
            font-size: 40px;
            color: #ff0;
            text-shadow: 0 0 20px #ff0;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .powerup-msg {
            font-size: 24px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            margin-top: 10px;
        }

        .boss-warning {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 50px;
            font-weight: 900;
            color: #f00;
            text-shadow: 0 0 20px #f00;
            animation: blink 0.5s infinite;
            display: none;
            pointer-events: none;
            z-index: 50;
            letter-spacing: 5px;
        }

        @keyframes blink {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(1.05); }
            100% { opacity: 1; transform: scale(1); }
        }

        .pause-btn {
            margin-top: 8px;
            align-self: flex-end;
        }

        #fireBtn {
            background: #ff3b3b;
            color: #fff;
            border-color: #ff7b7b;
            margin-left: 10px;
            display: none;
            pointer-events: auto;
            z-index: 60;
        }

        #fireBtn:hover {
            background: #ff5b5b;
            box-shadow: 0 0 15px #ff5b5b;
        }

        #game-over-screen, #tactical-screen, #joke-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 2px solid #0ff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            max-width: 80%;
            min-width: 300px;
            z-index: 100;
        }

        #start-screen {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 120;
            pointer-events: auto;
            text-align: center;
            overflow: hidden;
        }

        .menu-box {
            background: #222;
            padding: 40px;
            border-radius: 10px;
            border: 2px solid #4ade80;
            text-align: center;
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.2);
            max-width: 520px;
            width: 90%;
            transition: opacity 0.2s ease, transform 0.2s ease;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .menu-btn {
            background: #4ade80;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            color: #003300;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin: 8px;
            min-width: 220px;
            transition: transform 0.1s, background 0.2s;
        }

        .menu-btn:hover { background: #6ee7a0; }
        .menu-btn:active { transform: scale(0.97); }
        .menu-btn.active { background: #4ade80; color: #003300; }
        .menu-btn.secondary-btn { background: #4488ff; color: #001133; }
        .menu-btn.secondary-btn:hover { background: #6699ff; }
        .menu-btn.local-btn { background: #ffaa00; color: #331100; }
        .menu-btn.local-btn:hover { background: #ffcc00; }
        .menu-btn.danger-btn { background: #ff5555; color: #330000; }
        .menu-btn.danger-btn:hover { background: #ff7777; }
        
        #joke-overlay {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .joke-text {
            font-size: 24px;
            color: #0ff;
            font-style: italic;
            line-height: 1.4;
            min-height: 60px;
            white-space: pre-wrap;
        }

        h1 {
            margin: 0 0 10px 0;
            color: #0ff;
            font-size: 40px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        h2 {
            font-size: 24px;
            color: #ff0;
            margin: 10px 0;
        }

        p {
            color: #aaa;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .ai-text {
            color: #bbf;
            font-style: italic;
            border-left: 3px solid #0ff;
            padding-left: 15px;
            margin: 20px 0;
            text-align: left;
            background: rgba(0, 255, 255, 0.05);
            padding: 10px;
            white-space: pre-wrap;
        }

        .mission-stats {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            font-size: 14px;
            color: #888;
        }
        
        .stat-item {
            border: 1px solid #444;
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .stat-val {
            color: #fff;
            font-weight: bold;
        }

        button {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 12px 30px;
            font-size: 16px;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            margin: 5px;
        }

        button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 15px #0ff;
        }

        button:disabled {
            border-color: #555;
            color: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        .sparkle-btn {
            border-color: #f0f;
            color: #f0f;
        }
        
        .sparkle-btn:hover {
            background: #f0f;
            color: #fff;
            box-shadow: 0 0 15px #f0f;
        }
        
        .danger-btn {
            border-color: #f55;
            color: #f55;
            margin-top: 20px;
        }
        
        .danger-btn:hover {
            background: #f55;
            color: #fff;
            box-shadow: 0 0 15px #f55;
        }
        
        .mode-select-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .hidden {
            display: none !important;
        }

        .menu-hidden {
            opacity: 0;
            transform: translate(-50%, -50%) translateY(8px) scale(0.98);
            pointer-events: none;
        }

        /* Mobile controls hint */
        .mobile-hint {
            display: none;
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .mobile-hint { display: block; }
            h1 { font-size: 28px; }
            #game-over-screen, #joke-overlay { width: 85%; padding: 20px; }
            .menu-box { padding: 24px; }
            #arsenal-panel-p1,
            #arsenal-panel-p2 {
                left: 10px;
                right: 10px;
                width: auto;
                padding: 8px 10px;
            }
            #arsenal-panel-p1 { bottom: 10px; }
            #arsenal-panel-p2 { bottom: 70px; }
            .arsenal-player { flex-direction: row; }
            .modules-grid { flex-direction: row; gap: 6px; }
            .module-icon { width: 30px; height: 30px; font-size: 14px; }
            .heat-container { height: 12px; width: 120px; flex-direction: row; }
            .heat-bar-bg { width: 100%; height: 10px; }
            .heat-label {
                writing-mode: horizontal-tb;
                transform: none;
                margin-top: 0;
                margin-left: 6px;
            }
            #heat-bar-fill-p1,
            #heat-bar-fill-p2 {
                height: 100%;
                width: 0%;
                top: 0;
                bottom: auto;
            }
            #fireBtn {
                display: inline-block;
                position: absolute;
                left: 10px;
                bottom: 130px;
                margin-left: 0;
                z-index: 60;
                width: 120px;
                height: 44px;
                padding: 0;
                font-size: 14px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
            }
            .boss-warning { font-size: 30px; }
            .mode-select-container { flex-direction: column; gap: 10px; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-left">
                <div id="levelDisplay" style="color: #ff0;">LEVEL: 1</div>
                <div id="scoreDisplayP1">P1 SCORE: 0</div>
                <div id="scoreDisplayP2">P2 SCORE: 0</div>
            </div>
            <div class="hud-right">
                <div id="bossTimer">BOSS: 2:00</div>
                <div id="livesDisplayP1">P1 LIVES: 3</div>
                <div id="livesDisplayP2">P2 LIVES: 3</div>
                <button id="tacticalBtn" class="sparkle-btn pause-btn hidden" style="padding: 6px 12px; font-size: 12px;">Pause</button>
            </div>
        </div>
        
        <!-- Boss Warning Overlay -->
        <div id="bossWarning" class="boss-warning">⚠ WARNING: BOSS DETECTED ⚠</div>

        <!-- Arsenal Panel -->
        <div id="arsenal-panel-p2" class="arsenal-panel">
            <div>
                <div class="arsenal-label">P2</div>
                <div class="arsenal-player">
                    <div class="heat-container">
                        <div class="heat-bar-bg">
                            <div id="heat-bar-fill-p2"></div>
                        </div>
                        <div class="heat-label">HEAT</div>
                    </div>
                    <div class="modules-grid">
                        <div id="mod-spread-p2" class="module-icon">S <span id="mod-spread-lvl-p2" class="module-sub">0</span></div>
                        <div id="mod-laser-p2" class="module-icon">L <span id="mod-laser-lvl-p2" class="module-sub">0</span></div>
                        <div id="mod-missile-p2" class="module-icon">M <span id="mod-missile-lvl-p2" class="module-sub">0</span></div>
                        <div id="mod-rapid-p2" class="module-icon">R</div>
                        <div id="mod-shield-p2" class="module-icon">♥ <span id="mod-shield-lvl-p2" class="module-sub">0</span></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="arsenal-panel-p1" class="arsenal-panel">
            <div>
                <div class="arsenal-label">P1</div>
                <div class="arsenal-player">
                    <div class="heat-container">
                        <div class="heat-bar-bg">
                            <div id="heat-bar-fill-p1"></div>
                        </div>
                        <div class="heat-label">HEAT</div>
                    </div>
                    <div class="modules-grid">
                        <div id="mod-spread-p1" class="module-icon">S <span id="mod-spread-lvl-p1" class="module-sub">0</span></div>
                        <div id="mod-laser-p1" class="module-icon">L <span id="mod-laser-lvl-p1" class="module-sub">0</span></div>
                        <div id="mod-missile-p1" class="module-icon">M <span id="mod-missile-lvl-p1" class="module-sub">0</span></div>
                        <div id="mod-rapid-p1" class="module-icon">R</div>
                        <div id="mod-shield-p1" class="module-icon">♥ <span id="mod-shield-lvl-p1" class="module-sub">0</span></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="hud-center">
            <div id="levelUpMsg" class="level-up-msg">LEVEL UP!</div>
            <div id="powerUpMsg" class="powerup-msg">POWER UP!</div>
        </div>
        <button id="fireBtn" class="sparkle-btn" style="padding: 6px 16px; font-size: 12px;">Fire</button>
    </div>

    <!-- Modals -->
    <div id="joke-overlay" class="hidden">
        <h2>Critical Error: Pilot Offline</h2>
        <div id="jokeDisplay" class="joke-text"></div>
        <button id="continueBtn" class="sparkle-btn">Re-Initialize Ship</button>
    </div>

    <div id="start-screen">
        <div class="menu-box" id="menu-player">
            <h1>Neon Defender</h1>
            <p>Select Player Mode</p>
            <div class="mode-select-container">
                <button id="playerOneBtn" class="menu-btn active">1 Player</button>
                <button id="playerTwoBtn" class="menu-btn local-btn">2 Player Local</button>
            </div>
            <div class="mode-select-container">
                <button id="playerOnlineBtn" class="menu-btn secondary-btn" disabled>2 Player Online (Soon)</button>
            </div>
        </div>

        <div class="menu-box menu-hidden" id="menu-mode">
            <h1>Neon Defender</h1>
            <div id="mission-briefing">
                <p>System Initialized.</p>
            </div>
            <div class="mission-stats hidden" id="mission-modifiers">
                <div class="stat-item">SPD: <span class="stat-val" id="mod-spd">100%</span></div>
                <div class="stat-item">HP: <span class="stat-val" id="mod-hp">100%</span></div>
                <div class="stat-item">SWARM: <span class="stat-val" id="mod-spawn">100%</span></div>
            </div>
            <div class="ai-text" id="mission-text">
                Select Operation Mode...
            </div>
            <button id="genMissionBtn" class="menu-btn secondary-btn">Generate Mission</button>
            
            <div class="mode-select-container">
                <button id="startNormalBtn" class="menu-btn">Mission Mode</button>
                <button id="startBossBtn" class="menu-btn danger-btn">Boss Rush Mode</button>
            </div>
            <button id="backToPlayerBtn" class="menu-btn secondary-btn">Back</button>
            <p class="mobile-hint">Touch & Drag to Move/Shoot</p>
        </div>
    </div>

    <div id="tactical-screen" class="hidden">
        <h2>Tactical Computer</h2>
        <div class="ai-text" id="tactical-text">
            Analyzing combat data...
        </div>
        <button id="resumeBtn">Resume Combat</button>
        <button id="abortBtn" class="danger-btn">Abort Mission</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #f0f;">CRITICAL FAILURE</h1>
        <p id="finalScore">Score: 0</p>
        <div class="ai-text" id="analysis-text">
            Uploading black box data...
        </div>
        <button id="restartBtn">Reboot System</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreP1El = document.getElementById('scoreDisplayP1');
        const scoreP2El = document.getElementById('scoreDisplayP2');
        const levelEl = document.getElementById('levelDisplay');
        const livesP1El = document.getElementById('livesDisplayP1');
        const livesP2El = document.getElementById('livesDisplayP2');
        const levelUpMsg = document.getElementById('levelUpMsg');
        const powerUpMsg = document.getElementById('powerUpMsg');
        const bossWarningEl = document.getElementById('bossWarning');
        const bossTimerEl = document.getElementById('bossTimer');
        
        // Arsenal UI
        const heatBarFillP1 = document.getElementById('heat-bar-fill-p1');
        const modSpreadP1 = document.getElementById('mod-spread-p1');
        const modSpreadLvlP1 = document.getElementById('mod-spread-lvl-p1');
        const modLaserP1 = document.getElementById('mod-laser-p1');
        const modLaserLvlP1 = document.getElementById('mod-laser-lvl-p1');
        const modMissileP1 = document.getElementById('mod-missile-p1');
        const modMissileLvlP1 = document.getElementById('mod-missile-lvl-p1');
        const modRapidP1 = document.getElementById('mod-rapid-p1');
        const modShieldP1 = document.getElementById('mod-shield-p1');
        const modShieldLvlP1 = document.getElementById('mod-shield-lvl-p1');

        const heatBarFillP2 = document.getElementById('heat-bar-fill-p2');
        const modSpreadP2 = document.getElementById('mod-spread-p2');
        const modSpreadLvlP2 = document.getElementById('mod-spread-lvl-p2');
        const modLaserP2 = document.getElementById('mod-laser-p2');
        const modLaserLvlP2 = document.getElementById('mod-laser-lvl-p2');
        const modMissileP2 = document.getElementById('mod-missile-p2');
        const modMissileLvlP2 = document.getElementById('mod-missile-lvl-p2');
        const modRapidP2 = document.getElementById('mod-rapid-p2');
        const modShieldP2 = document.getElementById('mod-shield-p2');
        const modShieldLvlP2 = document.getElementById('mod-shield-lvl-p2');

        const arsenalUiP1 = {
            heatBarFill: heatBarFillP1,
            modSpread: modSpreadP1,
            modSpreadLvl: modSpreadLvlP1,
            modLaser: modLaserP1,
            modLaserLvl: modLaserLvlP1,
            modMissile: modMissileP1,
            modMissileLvl: modMissileLvlP1,
            modRapid: modRapidP1,
            modShield: modShieldP1,
            modShieldLvl: modShieldLvlP1
        };

        const arsenalUiP2 = {
            heatBarFill: heatBarFillP2,
            modSpread: modSpreadP2,
            modSpreadLvl: modSpreadLvlP2,
            modLaser: modLaserP2,
            modLaserLvl: modLaserLvlP2,
            modMissile: modMissileP2,
            modMissileLvl: modMissileLvlP2,
            modRapid: modRapidP2,
            modShield: modShieldP2,
            modShieldLvl: modShieldLvlP2
        };

        // Screens & Overlays
        const startScreen = document.getElementById('start-screen');
        const menuPlayer = document.getElementById('menu-player');
        const menuMode = document.getElementById('menu-mode');
        const gameOverScreen = document.getElementById('game-over-screen');
        const tacticalScreen = document.getElementById('tactical-screen');
        const jokeOverlay = document.getElementById('joke-overlay');
        const jokeEl = document.getElementById('jokeDisplay');

        // Buttons
        const startBtn = null; // Removed old startBtn
        const restartBtn = document.getElementById('restartBtn');
        const genMissionBtn = document.getElementById('genMissionBtn');
        const tacticalBtn = document.getElementById('tacticalBtn');
        const fireBtn = document.getElementById('fireBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const continueBtn = document.getElementById('continueBtn');
        const abortBtn = document.getElementById('abortBtn');
        const playerOneBtn = document.getElementById('playerOneBtn');
        const playerTwoBtn = document.getElementById('playerTwoBtn');
        const playerOnlineBtn = document.getElementById('playerOnlineBtn');
        const backToPlayerBtn = document.getElementById('backToPlayerBtn');
        const startNormalBtn = document.getElementById('startNormalBtn');
        const startBossBtn = document.getElementById('startBossBtn');

        // Text Areas
        const finalScoreEl = document.getElementById('finalScore');
        const missionText = document.getElementById('mission-text');
        const analysisText = document.getElementById('analysis-text');
        const tacticalText = document.getElementById('tactical-text');
        
        // Modifiers UI
        const missionModifiersEl = document.getElementById('mission-modifiers');
        const modSpdEl = document.getElementById('mod-spd');
        const modHpEl = document.getElementById('mod-hp');
        const modSpawnEl = document.getElementById('mod-spawn');

        const mobileQuery = window.matchMedia('(max-width: 768px)');
        let isMobileLayout = mobileQuery.matches;

        function updateMobileUi() {
            isMobileLayout = mobileQuery.matches;
            if (fireBtn) {
                fireBtn.style.display = isMobileLayout && gameRunning ? 'inline-block' : 'none';
            }
            if (playerTwoBtn) {
                playerTwoBtn.classList.toggle('hidden', isMobileLayout);
                playerTwoBtn.disabled = isMobileLayout;
            }
            if (playerOnlineBtn) {
                playerOnlineBtn.classList.toggle('hidden', isMobileLayout);
            }
            if (isMobileLayout && playerModeType !== 'single') {
                setPlayerMode('single');
                showPlayerMenu();
            }
        }

        // API config (Firebase uses client-safe key; Gemini uses server proxy)
        let envConfig = {};
        const envConfigEl = document.getElementById('neon-config');
        if (envConfigEl && envConfigEl.textContent) {
            try { envConfig = JSON.parse(envConfigEl.textContent); } catch {}
        }
        const firebaseApiKey = envConfig.firebaseApiKey || "";

        // Game State
        let gameRunning = false;
        let paused = false;
        let scoreP1 = 0;
        let scoreP2 = 0;
        let frames = 0;
        let level = 1;
        let nextLevelScore = 1000;
        let difficultyMultiplier = 1;
        let gameMode = 'normal'; // 'normal' or 'boss_rush'
        
        // FPS Cap Variables
        const FPS = 60;
        const frameInterval = 1000 / FPS;
        let lastFrameTime = 0;
        
        // Boss State
        let currentBoss = null;
        let bossesDefeated = 0;
        let framesSinceLastBoss = 0;
        const BOSS_TIME_LIMIT = 7200; // 2 minutes @ 60fps
        
        // Mission Configuration (Default)
        let missionConfig = {
            enemySpeed: 1.0,
            enemyHealth: 1.0,
            spawnRate: 1.0
        };
        
        // Message Timers
        let levelMsgTimeout;
        let powerUpMsgTimeout;

        const PLAYER_MODE_KEY = 'neondefender_player_mode';
        let playerCount = 1;
        let playerModeType = 'single'; // 'single' | 'local' | 'online'

        function teamScore() {
            return playerCount === 2 ? (scoreP1 + scoreP2) : scoreP1;
        }

        function updateScoreUI() {
            scoreP1El.innerText = "P1 SCORE: " + scoreP1;
            if (playerCount === 2) {
                scoreP2El.innerText = "P2 SCORE: " + scoreP2;
            }
        }

        function addScore(points, owner) {
            if (owner === player1) scoreP1 += points;
            else if (owner === player2) scoreP2 += points;
            else scoreP1 += points;
            updateScoreUI();
        }

        // --- GEMINI API INTEGRATION ---

        async function callGemini(prompt, targetElement) {
            targetElement.textContent = "Processing data stream...";
            targetElement.style.opacity = "0.7";
            
            try {
                const response = await fetch('/api/proxy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt })
                });

                if (!response.ok) throw new Error('API Uplink Failed');

                const data = await response.json();
                const text = data.candidates[0].content.parts[0].text;
                
                // Typewriter effect
                targetElement.textContent = "";
                targetElement.style.opacity = "1";
                let i = 0;
                const speed = 30;
                function typeWriter() {
                    if (i < text.length) {
                        targetElement.textContent += text.charAt(i);
                        i++;
                        setTimeout(typeWriter, speed);
                    }
                }
                typeWriter();

            } catch (error) {
                console.error(error);
                targetElement.textContent = "Error: Uplink severed. Standard protocols engaged.";
            }
        }

        async function generateMissionProfile() {
            missionText.textContent = "Negotiating Mission Parameters...";
            missionText.style.opacity = "0.7";
            genMissionBtn.disabled = true;

            const prompt = `
                You are a sci-fi game director. Generate a mission profile in JSON format.
                Do not include markdown formatting like \`\`\`json. Just the raw JSON.
                Return this structure:
                {
                    "operationName": "String (Cool Name)",
                    "objective": "String (1 sentence description)",
                    "enemySpeed": Number (0.8 to 1.5),
                    "enemyHealth": Number (0.8 to 1.5),
                    "spawnRate": Number (0.8 to 1.5)
                }
                Vary the stats: Make some fast/weak, some slow/tanky, some swarmy.
            `;

            try {
                const response = await fetch('/api/proxy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt })
                });

                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(errText || 'API Uplink Failed');
                }

                const data = await response.json();
                const text = data?.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) {
                    const apiMessage = data?.error?.message || "No response text returned.";
                    throw new Error(apiMessage);
                }
                let cleanedText = text;
                
                // Clean markdown if present
                cleanedText = cleanedText.replace(/```json/g, '').replace(/```/g, '').trim();
                
                const profile = JSON.parse(cleanedText);
                
                // Apply Global State
                missionConfig = {
                    enemySpeed: profile.enemySpeed || 1.0,
                    enemyHealth: profile.enemyHealth || 1.0,
                    spawnRate: profile.spawnRate || 1.0
                };

                // Update UI
                missionText.textContent = `OP: ${profile.operationName}\nOBJ: ${profile.objective}`;
                missionText.style.opacity = "1";
                
                missionModifiersEl.classList.remove('hidden');
                modSpdEl.innerText = Math.round(missionConfig.enemySpeed * 100) + "%";
                modHpEl.innerText = Math.round(missionConfig.enemyHealth * 100) + "%";
                modSpawnEl.innerText = Math.round(missionConfig.spawnRate * 100) + "%";
                
                // Color coding
                modSpdEl.style.color = missionConfig.enemySpeed > 1 ? '#f55' : '#5f5';
                modHpEl.style.color = missionConfig.enemyHealth > 1 ? '#f55' : '#5f5';
                modSpawnEl.style.color = missionConfig.spawnRate > 1 ? '#f55' : '#5f5';

            } catch (e) {
                console.error(e);
                missionText.textContent = "Error: Mission Uplink Failed. Defaulting to standard patrol.";
                missionConfig = { enemySpeed: 1, enemyHealth: 1, spawnRate: 1 };
                missionModifiersEl.classList.add('hidden');
            }
            genMissionBtn.disabled = false;
        }

        genMissionBtn.addEventListener('click', generateMissionProfile);

        tacticalBtn.addEventListener('click', () => {
            if (!gameRunning) return;
            paused = true;
            tacticalScreen.classList.remove('hidden');
            tacticalBtn.classList.add('hidden');
            
            const prompt = playerCount === 2
                ? `You are a helpful tactical spaceship AI. The pilots are paused. Current Status: P1 Lives ${player1.lives}, P2 Lives ${player2.lives}, Level ${level}, P1 Score ${scoreP1}, P2 Score ${scoreP2}. Give one short sentence of tactical advice or encouragement.`
                : `You are a helpful tactical spaceship AI. The pilot is paused. Current Status: Lives ${player1.lives}, Level ${level}, Score ${scoreP1}. Give one short sentence of tactical advice or encouragement.`;
            callGemini(prompt, tacticalText);
        });

        resumeBtn.addEventListener('click', () => {
            paused = false;
            tacticalScreen.classList.add('hidden');
            tacticalBtn.classList.remove('hidden');
            animate(0); // Pass a dummy time or rely on next rAF call
        });

        abortBtn.addEventListener('click', () => {
            // Reset and go to start screen
            gameRunning = false;
            paused = false;
            tacticalScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            showPlayerMenu();
            // Hide any other overlays
            jokeOverlay.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            bossWarningEl.style.display = 'none';
        });

        continueBtn.addEventListener('click', () => {
            jokeOverlay.classList.add('hidden');
            paused = false;
            
            if ((playerCount === 1 && player1.lives <= 0) || (playerCount === 2 && player1.lives <= 0 && player2.lives <= 0)) {
                gameOver();
            } else {
                // Respawn last hit player if still alive
                if (lastHitPlayer && lastHitPlayer.lives > 0) {
                    lastHitPlayer.x = lastHitPlayer.spawnX;
                    lastHitPlayer.y = lastHitPlayer.spawnY;
                    lastHitPlayer.invulnerable = 120; // 2 seconds safety
                }
                animate(0);
            }
        });

        function triggerGameOverAnalysis() {
            const prompt = `You are a sarcastic spaceship computer. The pilots just crashed their ships. Final Score P1: ${scoreP1}, P2: ${scoreP2}. Reached Level: ${level}. Give a one-sentence snarky performance review.`;
            callGemini(prompt, analysisText);
        }

        function triggerDeathComment() {
            paused = true; // Pause Game Loop
            jokeOverlay.classList.remove('hidden');
            
            const prompt = "You are a sarcastic spaceship AI. The pilot just exploded and lost a life. Give a very short (one sentence) roast about their piloting skills or a backhanded compliment. Be witty.";
            callGemini(prompt, jokeEl);
        }

        function updateArsenalUI(player, ui) {
            if (!player) return;

            // Heat Bar
            const heatPct = Math.min(100, (player.heat / player.maxHeat) * 100);
            if (isMobileLayout) {
                ui.heatBarFill.style.width = heatPct + '%';
                ui.heatBarFill.style.height = '100%';
            } else {
                ui.heatBarFill.style.height = heatPct + '%';
                ui.heatBarFill.style.width = '100%';
            }
            
            if (player.hasRapidFire) {
                ui.heatBarFill.style.backgroundColor = '#0ff'; // Blue for infinite
            } else if (player.overheated) {
                ui.heatBarFill.style.backgroundColor = '#f00'; // Red
            } else {
                if (heatPct > 75) {
                    ui.heatBarFill.style.backgroundColor = '#f80';
                } else {
                    ui.heatBarFill.style.backgroundColor = '#0f0';
                }
            }

            // Modules Active State (Weapon Switch)
            const isSpread = player.weaponMode === 'spread';
            const isLaser = player.weaponMode === 'laser';

            // Spread Icon
            ui.modSpread.className = 'module-icon'; // Reset
            if (isSpread) ui.modSpread.classList.add('module-active', 'weapon-active-spread');
            ui.modSpreadLvl.innerText = player.spreadLevel;

            // Laser Icon
            ui.modLaser.className = 'module-icon'; // Reset
            if (isLaser) ui.modLaser.classList.add('module-active', 'weapon-active-laser');
            ui.modLaserLvl.innerText = player.laserLevel;

            // Missile Icon
            ui.modMissile.classList.toggle('module-active', player.missileLevel > 0);
            ui.modMissile.style.borderColor = player.missileLevel > 0 ? '#f0f' : '#444';
            ui.modMissile.style.color = player.missileLevel > 0 ? '#f0f' : '#444';
            ui.modMissileLvl.innerText = player.missileLevel;

            ui.modRapid.classList.toggle('module-active', player.hasRapidFire);
            ui.modRapid.style.borderColor = player.hasRapidFire ? '#fa0' : '#444';
            ui.modRapid.style.color = player.hasRapidFire ? '#fa0' : '#444';

            // Shield Icon
            ui.modShield.classList.toggle('module-active', player.shieldLevel > 0);
            ui.modShield.style.borderColor = player.shieldLevel > 0 ? '#fff' : '#444';
            ui.modShield.style.color = player.shieldLevel > 0 ? '#fff' : '#444';
            ui.modShieldLvl.innerText = player.shieldLevel;
        }

        // --- GAME ENGINE ---

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            updateMobileUi();
        }
        window.addEventListener('resize', resize);
        resize();
        if (mobileQuery.addEventListener) {
            mobileQuery.addEventListener('change', updateMobileUi);
        } else if (mobileQuery.addListener) {
            mobileQuery.addListener(updateMobileUi);
        }

        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            Enter: false,
            Space: false,
            KeyW: false,
            KeyA: false,
            KeyS: false,
            KeyD: false
        };

        function setFireState(state) {
            if (playerCount === 2) {
                keys.Enter = state;
            } else {
                keys.Space = state;
            }
        }

        const pointer = {
            x: null,
            y: null,
            active: false
        };

        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.code === 'Space' || e.code === 'Enter') {
                e.preventDefault();
            }
            // Modal Navigation (Space/Enter to continue)
            if (!jokeOverlay.classList.contains('hidden') && (e.code === 'Space' || e.code === 'Enter')) {
                continueBtn.click();
                return; 
            }
            if (!gameOverScreen.classList.contains('hidden') && (e.code === 'Space' || e.code === 'Enter')) {
                restartBtn.click();
                return;
            }

            if (e.code === 'Space') keys.Space = true;
            if (e.code === 'Enter') keys.Enter = true;
            if (e.key === 'ArrowUp') keys.ArrowUp = true;
            if (e.key === 'ArrowDown') keys.ArrowDown = true;
            if (e.key === 'ArrowLeft') keys.ArrowLeft = true;
            if (e.key === 'ArrowRight') keys.ArrowRight = true;
            if (e.code === 'KeyW') keys.KeyW = true;
            if (e.code === 'KeyA') keys.KeyA = true;
            if (e.code === 'KeyS') keys.KeyS = true;
            if (e.code === 'KeyD') keys.KeyD = true;
            if (e.key === 't' || e.key === 'T') tacticalBtn.click();
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.code === 'Space' || e.code === 'Enter') {
                e.preventDefault();
            }
            if (e.code === 'Space') keys.Space = false;
            if (e.code === 'Enter') keys.Enter = false;
            if (e.key === 'ArrowUp') keys.ArrowUp = false;
            if (e.key === 'ArrowDown') keys.ArrowDown = false;
            if (e.key === 'ArrowLeft') keys.ArrowLeft = false;
            if (e.key === 'ArrowRight') keys.ArrowRight = false;
            if (e.code === 'KeyW') keys.KeyW = false;
            if (e.code === 'KeyA') keys.KeyA = false;
            if (e.code === 'KeyS') keys.KeyS = false;
            if (e.code === 'KeyD') keys.KeyD = false;
        });

        window.addEventListener('touchstart', (e) => {
            if (e.target && e.target.closest && e.target.closest('#fireBtn')) return;
            pointer.active = true;
            pointer.x = e.touches[0].clientX;
            pointer.y = e.touches[0].clientY;
        }, {passive: false});

        window.addEventListener('touchmove', (e) => {
            if (e.target && e.target.closest && e.target.closest('#fireBtn')) return;
            e.preventDefault(); 
            if (pointer.active) {
                pointer.x = e.touches[0].clientX;
                pointer.y = e.touches[0].clientY;
            }
        }, {passive: false});

        window.addEventListener('touchend', () => {
            pointer.active = false;
        });

        if (fireBtn) {
            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                setFireState(true);
            }, {passive: false});
            fireBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                setFireState(false);
            }, {passive: false});
            fireBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                setFireState(true);
            });
            fireBtn.addEventListener('mouseup', (e) => {
                e.preventDefault();
                setFireState(false);
            });
            fireBtn.addEventListener('mouseleave', () => {
                setFireState(false);
            });
        }

        // Fixed: Restored missing function to prevent ReferenceError
        function showPowerUpMsg(text, color) {
            powerUpMsg.innerText = text;
            powerUpMsg.style.color = color;
            powerUpMsg.style.textShadow = `0 0 10px ${color}`;
            
            clearTimeout(powerUpMsgTimeout);
            powerUpMsg.style.opacity = 1;
            
            powerUpMsgTimeout = setTimeout(() => {
                powerUpMsg.style.opacity = 0;
            }, 1500);
        }

        // CLASSES
        class Player {
            constructor(config) {
                this.width = 40;
                this.height = 50; 
                this.x = config.spawnX;
                this.y = config.spawnY;
                this.spawnX = config.spawnX;
                this.spawnY = config.spawnY;
                this.speed = 7;
                this.color = config.color;
                this.controls = config.controls;
                this.usePointer = config.usePointer;
                this.lives = 3;
                this.lastShot = 0;
                this.shootDelay = 15;
                this.shieldLevel = 0;
                this.invulnerable = 0;
                this.exploding = false;
                this.weaponMode = 'spread';
                this.spreadLevel = 0;
                this.laserLevel = 0;
                this.missileLevel = 0;
                this.heat = 0;
                this.maxHeat = 100;
                this.overheated = false;
                this.overheatTimer = 0;
                this.hasRapidFire = false;
                this.rapidFireTimer = 0;
            }
            draw() {
                if (this.lives <= 0) return;
                if (this.exploding) return;
                if (this.invulnerable > 0 && Math.floor(frames / 4) % 2 === 0) return;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.lineTo(this.x + this.width / 2, this.y + this.height - 10);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.closePath();
                ctx.fill();
                if (this.shieldLevel > 0) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, 40, 0, Math.PI * 2);
                    if (this.shieldLevel === 1) { ctx.strokeStyle = '#0ff'; ctx.fillStyle = 'rgba(0, 255, 255, 0.1)'; }
                    else if (this.shieldLevel === 2) { ctx.strokeStyle = '#00f'; ctx.fillStyle = 'rgba(0, 0, 255, 0.15)'; ctx.lineWidth = 3; }
                    else { ctx.strokeStyle = '#fff'; ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.lineWidth = 4; ctx.shadowBlur = 15; ctx.shadowColor = '#f0f'; }
                    ctx.stroke();
                    ctx.fill();
                    ctx.restore();
                }
                let activeLevel = this.weaponMode === 'spread' ? this.spreadLevel : this.laserLevel;
                let activeColor = this.weaponMode === 'spread' ? '#ff0' : '#0f0';
                if (activeLevel > 0) { ctx.fillStyle = activeColor; ctx.fillRect(this.x - 5, this.y + 20, 5, 10); ctx.fillRect(this.x + this.width, this.y + 20, 5, 10); }
                if (activeLevel > 2) { ctx.fillStyle = activeColor; ctx.fillRect(this.x - 10, this.y + 30, 5, 15); ctx.fillRect(this.x + this.width + 5, this.y + 30, 5, 15); }
                if (activeLevel >= 6) { ctx.fillStyle = '#f0f'; ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 4, 0, Math.PI*2); ctx.fill(); }
                if (Math.random() > 0.5) { ctx.fillStyle = '#f0f'; ctx.beginPath(); ctx.moveTo(this.x + this.width / 2 - 5, this.y + this.height - 5); ctx.lineTo(this.x + this.width / 2 + 5, this.y + this.height - 5); ctx.lineTo(this.x + this.width / 2, this.y + this.height + 15 + Math.random() * 10); ctx.closePath(); ctx.fill(); }
                ctx.shadowBlur = 0;
            }
            update() {
                if (this.lives <= 0) return;
                if (this.exploding) return;
                if (this.hasRapidFire) {
                    this.rapidFireTimer--;
                    if (this.rapidFireTimer <= 0) { this.hasRapidFire = false; showPowerUpMsg("RAPID FIRE ENDED", "#aaa"); }
                }
                if (this.overheated) {
                    this.overheatTimer--;
                    this.heat = (this.overheatTimer / 300) * 100; 
                    if (this.overheatTimer <= 0) { this.overheated = false; this.heat = 0; }
                } else if (!this.hasRapidFire) {
                    if (!keys[this.controls.shoot]) { this.heat = Math.max(0, this.heat - 0.5); }
                }
                if (this.invulnerable > 0) this.invulnerable--;
                if (keys[this.controls.left]) this.x -= this.speed;
                if (keys[this.controls.right]) this.x += this.speed;
                if (keys[this.controls.up] && this.y > 0) this.y -= this.speed;
                if (keys[this.controls.down] && this.y + this.height < canvas.height) this.y += this.speed;
                if (this.x + this.width < 0) this.x = canvas.width; else if (this.x > canvas.width) this.x = -this.width;
                if (this.usePointer && pointer.active) {
                    const targetX = pointer.x - this.width/2;
                    const targetY = pointer.y - 30; 
                    this.x += (targetX - this.x) * 0.2;
                    this.y += (targetY - this.y) * 0.2;
                }
                const currentShootDelay = this.hasRapidFire ? 5 : this.shootDelay;
                if (keys[this.controls.shoot] && (!this.overheated || this.hasRapidFire) && frames - this.lastShot > currentShootDelay) { this.shoot(); this.lastShot = frames; }
                if (this.missileLevel > 0 && frames % 60 === 0 && (enemies.length > 0 || currentBoss)) {
                    let count = Math.max(1, this.missileLevel);
                    for (let i = 0; i < count; i++) { setTimeout(() => { projectiles.push(new HomingMissile(this.x + this.width/2, this.y, -15 + (i * 10), this)); }, i * 100); }
                }
            }
        shoot() {
            if (!this.hasRapidFire) {
                this.heat += 6; 
                if (this.heat >= this.maxHeat) { this.heat = this.maxHeat; this.overheated = true; this.overheatTimer = 300; showPowerUpMsg("OVERHEATED!", "#f00"); }
            } else { this.heat = 0; this.overheated = false; }
            let type = this.weaponMode === 'laser' ? 'laser' : 'normal';
            let cx = this.x + this.width / 2;
            let cy = this.y;
            const spawn = (ox, oy, angle) => projectiles.push(new Projectile(cx + ox, cy + oy, false, type, angle, this));
                if (type === 'laser') {
                    if (this.laserLevel === 0) spawn(0, 0, 0);
                    else if (this.laserLevel === 1) { spawn(-10, 0, 0); spawn(10, 0, 0); }
                    else if (this.laserLevel === 2) { spawn(-15, 0, 0); spawn(0, -5, 0); spawn(15, 0, 0); }
                    else if (this.laserLevel === 3) { spawn(0, -5, 0); spawn(0, 0, -0.15); spawn(0, 0, 0.15); }
                    else if (this.laserLevel === 4) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.2); spawn(0, 0, 0.2); }
                    else if (this.laserLevel === 5) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.2); spawn(0, 0, 0.2); spawn(0, 5, -1.0); spawn(0, 5, 1.0); }
                    else if (this.laserLevel >= 6) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.2); spawn(0, 0, 0.2); spawn(0, 5, -1.0); spawn(0, 5, 1.0); spawn(0, 10, Math.PI); spawn(0, 8, Math.PI - 0.4); spawn(0, 8, Math.PI + 0.4); }
                } else {
                    if (this.spreadLevel === 0) spawn(0, 0, 0);
                    else if (this.spreadLevel === 1) { spawn(-10, 0, 0); spawn(10, 0, 0); }
                    else if (this.spreadLevel === 2) { spawn(-15, 0, 0); spawn(0, -5, 0); spawn(15, 0, 0); }
                    else if (this.spreadLevel === 3) { spawn(0, -5, 0); spawn(0, 0, -0.2); spawn(0, 0, 0.2); }
                    else if (this.spreadLevel === 4) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.3); spawn(0, 0, 0.3); }
                    else if (this.spreadLevel === 5) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.3); spawn(0, 0, 0.3); spawn(0, 5, -1.4); spawn(0, 5, 1.4); }
                    else if (this.spreadLevel >= 6) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.3); spawn(0, 0, 0.3); spawn(0, 5, -1.5); spawn(0, 5, 1.5); spawn(0, 10, Math.PI); spawn(0, 8, Math.PI - 0.4); spawn(0, 8, Math.PI + 0.4); }
                }
            }
        }

        class Projectile {
            constructor(x, y, isEnemy, type = 'normal', angle = 0, owner = null) {
                this.x = x; this.y = y; this.isEnemy = isEnemy; this.type = type; this.angle = angle;
                this.owner = owner;
                this.radius = isEnemy ? 4 : 3; if (type === 'laser') this.radius = 4;
                this.color = isEnemy ? '#f44' : '#ff0'; if (type === 'laser') this.color = '#0ff';
                this.speed = isEnemy ? 6 : 10; if (type === 'laser') this.speed = 18;
                this.markedForDeletion = false; this.piercing = (type === 'laser');
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                if (this.type === 'laser') { ctx.rotate(this.angle); ctx.fillStyle = this.color; ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.fillRect(-3, -20, 6, 40); }
                else { ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.fill(); }
                ctx.restore();
            }
            update() {
                if (this.isEnemy) { this.y += this.speed; if(this.angle !== 0) this.x += Math.sin(this.angle) * this.speed; if (this.y > canvas.height) this.markedForDeletion = true; }
                else { this.x += Math.sin(this.angle) * this.speed; this.y -= Math.cos(this.angle) * this.speed; if (this.y < 0 || this.x < 0 || this.x > canvas.width || this.y > canvas.height) this.markedForDeletion = true; }
            }
        }

        class HomingMissile extends Projectile {
            constructor(x, y, initialOffset = 0, owner = null) {
                super(x + initialOffset, y, false, 'missile', 0, owner);
                this.color = '#f0f'; this.speed = 5; this.target = null; this.radius = 5; this.turnSpeed = 0.08; this.life = 120;
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(4, 4); ctx.lineTo(0, 2); ctx.lineTo(-4, 4); ctx.closePath(); ctx.fill();
                if (frames % 4 === 0) particles.push(new Particle(this.x, this.y + 5, '#aaa')); ctx.restore();
            }
            update() {
                this.life--; if (this.life <= 0) { this.markedForDeletion = true; createBlast(this.x, this.y, this.owner); createExplosion(this.x, this.y, '#aaa', 5); return; }
                if (!this.target || this.target.markedForDeletion) {
                    if (currentBoss) this.target = currentBoss;
                    else { let minDist = Infinity; let closest = null; enemies.forEach(e => { let d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minDist) { minDist = d; closest = e; } }); this.target = closest; }
                }
                if (this.target) { this.x += (this.target.x + (this.target.width?this.target.width/2:0) - this.x) * this.turnSpeed; this.y += (this.target.y + (this.target.height?this.target.height/2:0) - this.y) * this.turnSpeed; }
                else { this.y -= this.speed; }
                if (this.y < 0 || this.y > canvas.height) this.markedForDeletion = true;
            }
        }

        class Boss {
            constructor(difficulty) {
                this.width = 120; this.height = 80; this.x = canvas.width / 2 - this.width / 2; this.y = -150; this.targetY = 80;
                this.hp = 100 + (difficulty * 50); this.maxHp = this.hp; this.state = 'entering';
                this.moveTimer = 0; this.attackTimer = 0; 
                this.speed = 1.5;
                this.attackInterval = 120; 
                this.minionSpawnInterval = 600;
                this.minionSpawnCount = 2;

                if (gameMode === 'boss_rush') {
                    if (difficulty === 0) {
                        this.speed = 1.5 * 0.25; 
                        this.attackInterval = 270; 
                        this.minionSpawnInterval = 300;
                        this.minionSpawnCount = 1;
                    } else {
                        this.speed = 1.5 + (difficulty * 0.1); 
                        this.attackInterval = Math.max(60, 120 - (difficulty * 5));
                        this.minionSpawnInterval = Math.max(200, 600 - (difficulty * 20));
                        this.minionSpawnCount = 2 + Math.floor(difficulty / 3);
                    }
                }
                this.color = '#f00'; this.markedForDeletion = false;
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = this.color; ctx.shadowBlur = 20; ctx.shadowColor = '#f00';
                ctx.beginPath(); ctx.moveTo(this.width/2, this.height); ctx.lineTo(this.width, 0); ctx.lineTo(this.width/2, 20); ctx.lineTo(0, 0); ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.width/2, 40, 15, 0, Math.PI*2); ctx.fill(); ctx.restore();
                const barW = 300; const barH = 20; const barX = (canvas.width - barW) / 2; const barY = 20;
                ctx.fillStyle = '#333'; ctx.fillRect(barX, barY, barW, barH);
                ctx.fillStyle = '#f00'; ctx.fillRect(barX, barY, barW * (this.hp / this.maxHp), barH);
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(barX, barY, barW, barH);
                ctx.fillStyle = '#fff'; ctx.font = '16px Courier New'; ctx.fillText("OMEGA CLASS THREAT", barX + 60, barY + 16);
            }
            update() {
                if (this.state === 'entering') { this.y += 2; if (this.y >= this.targetY) this.state = 'idle'; }
                else if (this.state === 'idle') {
                    this.x += Math.sin(frames * 0.02) * this.speed * 2;
                    this.attackTimer++;
                    if (this.attackTimer > this.attackInterval) { this.attack(); this.attackTimer = 0; }
                    if (frames % this.minionSpawnInterval === 0) { 
                        for(let i=0; i < this.minionSpawnCount; i++) enemies.push(new SwarmEnemy()); 
                    }
                }
            }
            attack() {
                const rand = Math.random();
                if (rand < 0.4) { for(let i=-2; i<=2; i++) projectiles.push(new Projectile(this.x + this.width/2, this.y + this.height, true, 'normal', i*0.2)); }
                else { let p = new Projectile(this.x + this.width/2, this.y + this.height, true, 'laser', 0); p.radius = 8; p.speed = 8; projectiles.push(p); }
            }
        }

        class PowerUp {
            constructor(x, y) {
                this.x = x; this.y = y; this.radius = 15; this.speed = 3; this.markedForDeletion = false;
                const rand = Math.random();
                if (rand < 0.3) { this.type = 'S'; this.color = '#0ff'; this.text = 'S'; }
                else if (rand < 0.5) { this.type = 'M'; this.color = '#f0f'; this.text = 'M'; }
                else if (rand < 0.65) { this.type = 'L'; this.color = '#0f0'; this.text = 'L'; }
                else if (rand < 0.85) { this.type = 'R'; this.color = '#fa0'; this.text = 'R'; }
                else { this.type = 'H'; this.color = '#fff'; this.text = '♥'; }
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                let scale = 1 + Math.sin(frames * 0.1) * 0.1; ctx.scale(scale, scale);
                ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = this.color; ctx.stroke();
                ctx.fillStyle = this.color; ctx.font = "bold 16px Courier New"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(this.text, 0, 1); ctx.restore();
            }
            update() { this.y += this.speed; if (this.y > canvas.height) this.markedForDeletion = true; }
        }

        class Enemy { constructor() { this.markedForDeletion = false; } draw() {} update() {} dropPowerUp() { if (Math.random() < 0.15) powerUps.push(new PowerUp(this.x, this.y)); } }
        class SwarmEnemy extends Enemy {
            constructor() { super(); this.radius = 15 + Math.random() * 15; this.x = Math.random() * (canvas.width - this.radius * 2) + this.radius; this.y = -this.radius; this.color = `hsl(${Math.random() * 60 + 300}, 100%, 50%)`; this.speed = ((Math.random() * 2 + 1) * difficultyMultiplier) * missionConfig.enemySpeed; this.angle = 0; this.spinSpeed = Math.random() * 0.1 - 0.05; this.health = Math.max(1, Math.floor((this.radius / 8) * missionConfig.enemyHealth)); this.points = 100; }
            draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.beginPath(); for (let i = 0; i < 6; i++) ctx.lineTo(this.radius * Math.cos(i * Math.PI / 3), this.radius * Math.sin(i * Math.PI / 3)); ctx.closePath(); ctx.stroke(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, this.radius/3, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
            update() { this.y += this.speed; this.angle += this.spinSpeed; if (this.y - this.radius > canvas.height) this.markedForDeletion = true; }
        }
        class InterceptorEnemy extends Enemy {
            constructor() { super(); this.width = 30; this.height = 30; this.x = Math.random() * (canvas.width - this.width); this.y = -this.height; this.speed = ((3 + Math.random()) * difficultyMultiplier) * missionConfig.enemySpeed; this.color = '#fa0'; this.health = Math.max(1, Math.floor(2 * missionConfig.enemyHealth)); this.points = 200; this.initialX = this.x; this.wobbleSpeed = Math.random() * 0.05 + 0.02; this.wobbleDist = 50; }
            draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.beginPath(); ctx.moveTo(-15, -15); ctx.lineTo(15, -15); ctx.lineTo(0, 15); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(0, -15, 5, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
            update() { this.y += this.speed; this.x = this.initialX + Math.sin(frames * this.wobbleSpeed) * this.wobbleDist; if (this.y > canvas.height) this.markedForDeletion = true; if (Math.random() < 0.015) projectiles.push(new Projectile(this.x, this.y + 10, true)); }
        }
        class Particle {
            constructor(x, y, color) { this.x = x; this.y = y; this.radius = Math.random() * 3; this.color = color; this.velocity = { x: (Math.random() - 0.5) * 8, y: (Math.random() - 0.5) * 8 }; this.alpha = 1; this.markedForDeletion = false; }
            draw() { ctx.save(); ctx.globalAlpha = this.alpha; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill(); ctx.restore(); }
            update() { this.x += this.velocity.x; this.y += this.velocity.y; this.alpha -= 0.02; if (this.alpha <= 0) this.markedForDeletion = true; }
        }
        class Star {
            constructor() { this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.size = Math.random() * 2; this.speed = Math.random() * 3 + 0.5; }
            draw() { ctx.fillStyle = '#fff'; ctx.globalAlpha = Math.random() * 0.5 + 0.3; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1.0; }
            update() { this.y += this.speed; if (this.y > canvas.height) { this.y = 0; this.x = Math.random() * canvas.width; } }
        }

        // Global Arrays
        let player1;
        let player2;
        let lastHitPlayer = null;
        let projectiles = [];
        let enemies = [];
        let particles = [];
        let stars = [];
        let powerUps = [];

        function init(mode) {
            if (jokeOverlay) jokeOverlay.classList.add('hidden');
            levelUpMsg.style.opacity = "0"; clearTimeout(levelMsgTimeout);
            const baseY = canvas.height - 100;
            const p1X = canvas.width / 2 - 90;
            const p2X = canvas.width / 2 + 50;
            const controlsP1 = playerCount === 2
                ? { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', shoot: 'Enter' }
                : { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', shoot: 'Space' };
            const controlsP2 = { up: 'KeyW', down: 'KeyS', left: 'KeyA', right: 'KeyD', shoot: 'Space' };
            gameMode = mode;
            player1 = new Player({ spawnX: p1X, spawnY: baseY, color: '#0ff', controls: controlsP1, usePointer: true });
            player2 = playerCount === 2 ? new Player({ spawnX: p2X, spawnY: baseY, color: '#fa0', controls: controlsP2, usePointer: false }) : null;
            projectiles = []; enemies = []; particles = []; stars = []; powerUps = [];
            lastHitPlayer = null;
            scoreP1 = 0; scoreP2 = 0; level = 1; nextLevelScore = 1000; frames = 0; difficultyMultiplier = 1; paused = false;
            currentBoss = null; bossesDefeated = 0; framesSinceLastBoss = 0;
            for(let i=0; i<100; i++) stars.push(new Star());
            updateScoreUI();
            levelEl.innerText = "LEVEL: " + level;
            livesP1El.innerText = "P1 LIVES: 3";
            livesP2El.innerText = "P2 LIVES: 3";
            livesP1El.style.color = '#fff';
            livesP2El.style.color = '#fff';
            scoreP2El.classList.toggle('hidden', playerCount !== 2);
            livesP2El.classList.toggle('hidden', playerCount !== 2);
            document.getElementById('arsenal-panel-p2').classList.toggle('hidden', playerCount !== 2);
            gameRunning = true; startScreen.classList.add('hidden'); gameOverScreen.classList.add('hidden'); tacticalBtn.classList.remove('hidden');
            updateMobileUi();
            animate(0); // Pass dummy time
        }

        function applyPlayerModeUI(type) {
            playerOneBtn.classList.toggle('active', type === 'single');
            playerTwoBtn.classList.toggle('active', type === 'local');
        }

        function setPlayerMode(type) {
            playerModeType = type;
            if (type === 'single') playerCount = 1;
            if (type === 'local') playerCount = 2;
            applyPlayerModeUI(type);
            try { localStorage.setItem(PLAYER_MODE_KEY, type); } catch {}
        }

        function showPlayerMenu() {
            menuPlayer.classList.remove('menu-hidden');
            menuMode.classList.add('menu-hidden');
        }

        function showModeMenu() {
            menuPlayer.classList.add('menu-hidden');
            menuMode.classList.remove('menu-hidden');
        }

        playerOneBtn.addEventListener('click', () => { setPlayerMode('single'); showModeMenu(); });
        playerTwoBtn.addEventListener('click', () => { setPlayerMode('local'); showModeMenu(); });

        const savedMode = (() => {
            try { return localStorage.getItem(PLAYER_MODE_KEY); } catch { return null; }
        })();
        if (savedMode === 'local' || savedMode === 'single') {
            setPlayerMode(savedMode);
        } else {
            applyPlayerModeUI(playerModeType);
        }

        if (playerOnlineBtn) {
            playerOnlineBtn.addEventListener('click', () => {
                alert('Online co-op is coming soon!');
            });
        }

        backToPlayerBtn.addEventListener('click', showPlayerMenu);

        startNormalBtn.addEventListener('click', () => init('normal'));
        startBossBtn.addEventListener('click', () => init('boss_rush'));
        restartBtn.addEventListener('click', () => init(gameMode));

        function initBoss() {
            if (currentBoss) return; 
            bossWarningEl.style.display = 'block';
            setTimeout(() => { bossWarningEl.style.display = 'none'; currentBoss = new Boss(bossesDefeated); }, 3000);
        }

        function spawnEnemies() {
            if (gameMode === 'boss_rush') { if (!currentBoss && bossWarningEl.style.display !== 'block') { if (frames % 120 === 0) initBoss(); } return; }
            if (currentBoss || bossWarningEl.style.display === 'block') return;
            let spawnRate = Math.max(20, 60 - (level * 5));
            let moddedRate = Math.max(10, Math.floor(spawnRate / missionConfig.spawnRate));
            if (frames % moddedRate === 0) {
                let rand = Math.random();
                let interceptorChance = (level > 1) ? Math.min(0.5, (level - 1) * 0.15) : 0;
                if (rand < interceptorChance) enemies.push(new InterceptorEnemy()); else enemies.push(new SwarmEnemy());
            }
        }

        function checkLevelUp() {
            if (gameMode === 'normal') {
                if (teamScore() >= nextLevelScore) {
                    level++; nextLevelScore += 1000 + (level * 500); difficultyMultiplier += 0.2; levelEl.innerText = "LEVEL: " + level;
                    clearTimeout(levelMsgTimeout); levelUpMsg.style.opacity = "1"; levelMsgTimeout = setTimeout(() => { levelUpMsg.style.opacity = "0"; }, 2000);
                    if (level % 5 === 0) initBoss();
                }
            } else { levelEl.innerText = "BOSS: " + (bossesDefeated + 1); }
        }

        function createExplosion(x, y, color, count = 20) { for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color)); }

        function createBlast(x, y, owner) {
            for (let i = 0; i < 20; i++) { const angle = (Math.PI * 2 / 20) * i; particles.push(new Particle(x, y, '#0ff')); particles[particles.length-1].velocity.x = Math.cos(angle) * 5; particles[particles.length-1].velocity.y = Math.sin(angle) * 5; }
            const blastRadius = 80; const damage = 1; 
            enemies.forEach((enemy) => {
                const dist = Math.hypot(x - enemy.x, y - enemy.y);
                if (dist < blastRadius + (enemy.radius || 20)) {
                    enemy.health -= damage; createExplosion(enemy.x, enemy.y, '#0ff', 5);
                    if (enemy.health <= 0) {
                        createExplosion(enemy.x, enemy.y, enemy.color, 20); enemy.dropPowerUp();
                        setTimeout(() => { const idx = enemies.indexOf(enemy); if (idx > -1) { enemies.splice(idx, 1); addScore(enemy.points, owner); checkLevelUp(); } }, 0);
                    }
                }
            });
            if (currentBoss && currentBoss.state !== 'entering') {
                const bx = currentBoss.x + currentBoss.width/2; const by = currentBoss.y + currentBoss.height/2;
                const dist = Math.hypot(x - bx, y - by);
                if (dist < blastRadius + 60) {
                    currentBoss.hp -= damage; createExplosion(bx, by, '#fff', 5);
                    if (currentBoss.hp <= 0) {
                         createExplosion(currentBoss.x + currentBoss.width/2, currentBoss.y + currentBoss.height/2, '#f00', 100);
                         for(let k=0; k<5; k++) powerUps.push(new PowerUp(currentBoss.x + Math.random()*100, currentBoss.y + Math.random()*50));
                         currentBoss = null; bossesDefeated++; framesSinceLastBoss = 0; addScore(5000, owner);
                         if(gameMode === 'boss_rush') difficultyMultiplier += 0.5;
                    }
                }
            }
        }

        function playerHit(p) {
            if (!p || p.invulnerable > 0 || p.exploding || p.lives <= 0) return;
            lastHitPlayer = p;
            if (p.shieldLevel > 0) { p.shieldLevel--; createExplosion(p.x + p.width/2, p.y + p.height/2, '#0ff', 30); p.invulnerable = 60; showPowerUpMsg("SHIELD -" + (p.shieldLevel+1), "#f00"); return; }
            p.lives--;
            if (p === player1) { livesP1El.innerText = "P1 LIVES: " + p.lives; livesP1El.style.color = '#f00'; }
            if (p === player2) { livesP2El.innerText = "P2 LIVES: " + p.lives; livesP2El.style.color = '#f00'; }
            createExplosion(p.x + p.width/2, p.y + p.height/2, '#f0f', 80);
            enemies = []; projectiles = [];
            p.spreadLevel = 0; p.laserLevel = 0; p.missileLevel = 0; p.weaponMode = 'spread'; p.hasRapidFire = false; p.heat = 0; p.overheated = false;
            p.x = -1000; p.exploding = true;
            setTimeout(() => {
                p.exploding = false;
                if (p.lives <= 0) {
                    if (playerCount === 1) { gameOver(); }
                    else { triggerDeathComment(); }
                    return;
                }
                if (currentBoss && p.lives > 0) { p.x = p.spawnX; p.y = p.spawnY; p.invulnerable = 120; }
                else { triggerDeathComment(); }
            }, 1500);
        }

        function checkCollisions() {
            const players = [player1, player2].filter(Boolean);
            projectiles.forEach((projectile, pIndex) => {
                if (projectile.isEnemy) {
                    let hitPlayer = false;
                    players.forEach((p) => {
                        if (hitPlayer || p.exploding || p.lives <= 0) return;
                        const dist = Math.hypot(projectile.x - (p.x + p.width/2), projectile.y - (p.y + p.height/2));
                        if (dist < 20) { playerHit(p); hitPlayer = true; setTimeout(() => projectiles.splice(pIndex, 1), 0); }
                    });
                } else {
                    let hit = false;
                    enemies.forEach((enemy, eIndex) => {
                        if(hit) return; 
                        let hitRadius = enemy.radius || 20; const dist = Math.hypot(projectile.x - enemy.x, projectile.y - enemy.y);
                        if (dist - hitRadius - projectile.radius < 1) {
                            hit = true; enemy.health--;
                            if (projectile.type === 'missile') createExplosion(projectile.x, projectile.y, '#f0f', 15); else createExplosion(projectile.x, projectile.y, '#ff0', 5);
                            if (!projectile.piercing) { setTimeout(() => projectiles.splice(pIndex, 1), 0); if (projectile.type === 'missile') createBlast(projectile.x, projectile.y, projectile.owner); } else { createExplosion(projectile.x, projectile.y, '#0ff', 5); }
                            if (enemy.health <= 0) { createExplosion(enemy.x, enemy.y, enemy.color, 20); enemy.dropPowerUp(); setTimeout(() => enemies.splice(eIndex, 1), 0); addScore(enemy.points, projectile.owner); checkLevelUp(); }
                        }
                    });
                    if (!hit && currentBoss && currentBoss.state !== 'entering') {
                        if (projectile.x > currentBoss.x && projectile.x < currentBoss.x + currentBoss.width && projectile.y > currentBoss.y && projectile.y < currentBoss.y + currentBoss.height) {
                            hit = true; currentBoss.hp--; createExplosion(projectile.x, projectile.y, '#fff', 5);
                            if (!projectile.piercing) { setTimeout(() => projectiles.splice(pIndex, 1), 0); if (projectile.type === 'missile') createBlast(projectile.x, projectile.y, projectile.owner); }
                            
                            // Fixed: Check if currentBoss exists before accessing properties to prevent crash on missile kill
                            if (currentBoss && currentBoss.hp <= 0) { 
                                createExplosion(currentBoss.x + currentBoss.width/2, currentBoss.y + currentBoss.height/2, '#f00', 100); 
                                for(let k=0; k<5; k++) powerUps.push(new PowerUp(currentBoss.x + Math.random()*100, currentBoss.y + Math.random()*50)); 
                                currentBoss = null; bossesDefeated++; framesSinceLastBoss = 0; addScore(5000, projectile.owner); 
                                if(gameMode === 'boss_rush') difficultyMultiplier += 0.5; 
                            }
                        }
                    }
                }
            });
            enemies.forEach((enemy, index) => {
                players.forEach((p) => {
                    if (p.exploding || p.lives <= 0) return;
                    if (enemy.x > p.x && enemy.x < p.x + p.width && enemy.y > p.y && enemy.y < p.y + p.height) {
                        playerHit(p); createExplosion(enemy.x, enemy.y, '#f00', 30); enemies.splice(index, 1);
                    }
                });
            });
            
            // NEW: Boss Body Collision Check
            if (currentBoss && currentBoss.state !== 'entering') {
                players.forEach((p) => {
                    if (p.exploding || p.lives <= 0) return;
                    if (p.x < currentBoss.x + currentBoss.width &&
                        p.x + p.width > currentBoss.x &&
                        p.y < currentBoss.y + currentBoss.height &&
                        p.y + p.height > currentBoss.y) {
                        playerHit(p);
                    }
                });
            }

            powerUps.forEach((pu, index) => {
                let picked = false;
                players.forEach((p) => {
                    if (picked || p.exploding || p.lives <= 0) return;
                    const dist = Math.hypot(pu.x - (p.x + p.width/2), pu.y - (p.y + p.height/2));
                    if (dist < 30) {
                        if (pu.type === 'S') { if (p.weaponMode !== 'spread') { p.weaponMode = 'spread'; showPowerUpMsg("SPREAD MODE", "#0ff"); } else { p.spreadLevel = Math.min(6, p.spreadLevel + 1); showPowerUpMsg("SPREAD UP!", "#0ff"); } }
                        else if (pu.type === 'M') { p.missileLevel = Math.min(6, p.missileLevel + 1); showPowerUpMsg("MISSILE LVL " + p.missileLevel, "#f0f"); }
                        else if (pu.type === 'L') { if (p.weaponMode !== 'laser') { p.weaponMode = 'laser'; showPowerUpMsg("LASER MODE", "#0f0"); } else { p.laserLevel = Math.min(6, p.laserLevel + 1); showPowerUpMsg("LASER UP!", "#0f0"); } }
                        else if (pu.type === 'R') { p.hasRapidFire = true; p.rapidFireTimer = 300; p.overheated = false; p.heat = 0; showPowerUpMsg("RAPID FIRE (5s)", "#fa0"); }
                        else if (pu.type === 'H') { p.shieldLevel = Math.min(3, p.shieldLevel + 1); showPowerUpMsg("SHIELD LVL " + p.shieldLevel, "#fff"); }
                        powerUps.splice(index, 1);
                        picked = true;
                    }
                });
            });
        }

        function gameOver() {
            gameRunning = false;
            gameOverScreen.classList.remove('hidden');
            tacticalBtn.classList.add('hidden');
            updateMobileUi();
            finalScoreEl.innerText = `P1 Score: ${scoreP1} | P2 Score: ${scoreP2}`;
            triggerGameOverAnalysis();
        }

        function animate(timestamp) {
            if (!gameRunning || paused) return;
            requestAnimationFrame(animate);

            if (!lastFrameTime) lastFrameTime = timestamp;
            const elapsed = timestamp - lastFrameTime;

            if (elapsed > frameInterval) {
                lastFrameTime = timestamp - (elapsed % frameInterval);

                ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                stars.forEach(star => { star.update(); star.draw(); });
                player1.update(); player1.draw(); updateArsenalUI(player1, arsenalUiP1);
                if (player2) {
                    player2.update(); player2.draw(); updateArsenalUI(player2, arsenalUiP2);
                }
                if (currentBoss) { currentBoss.update(); currentBoss.draw(); bossTimerEl.innerText = "BOSS: ACTIVE"; bossTimerEl.style.color = "#f00"; }
                else { 
                    if (gameMode === 'normal') { framesSinceLastBoss++; let timeUntilBoss = Math.max(0, BOSS_TIME_LIMIT - framesSinceLastBoss); let seconds = Math.floor(timeUntilBoss / 60); let mins = Math.floor(seconds / 60); let secs = seconds % 60; bossTimerEl.innerText = `BOSS: ${mins}:${secs < 10 ? '0' : ''}${secs}`; bossTimerEl.style.color = "#fff"; if (framesSinceLastBoss > BOSS_TIME_LIMIT) { initBoss(); framesSinceLastBoss = 0; } }
                    else { bossTimerEl.innerText = "BOSS RUSH"; bossTimerEl.style.color = "#f55"; }
                }
                powerUps.forEach((pu, index) => { pu.update(); pu.draw(); if (pu.markedForDeletion) powerUps.splice(index, 1); });
                projectiles.forEach((projectile, index) => { projectile.update(); projectile.draw(); if (projectile.markedForDeletion) projectiles.splice(index, 1); });
                enemies.forEach((enemy, index) => { enemy.update(); enemy.draw(); if (enemy.markedForDeletion) enemies.splice(index, 1); });
                particles.forEach((particle, index) => { particle.update(); particle.draw(); if (particle.markedForDeletion) particles.splice(index, 1); });
                if (!player1.exploding || (player2 && !player2.exploding)) spawnEnemies();
                checkCollisions();
                frames++;
            }
        }

        // Removed startBtn event listener to fix error
        startNormalBtn.addEventListener('click', () => init('normal'));
        startBossBtn.addEventListener('click', () => init('boss_rush'));
        restartBtn.addEventListener('click', () => init(gameMode));

        // Pre-load a mission for flavor
        window.addEventListener('load', () => {
             const prompt = "Generate a very short, cool sci-fi operation name (e.g., Operation: Red Dawn). 4 words max.";
             callGemini(prompt, missionText);
        });

    </script>
</body>
</html>
