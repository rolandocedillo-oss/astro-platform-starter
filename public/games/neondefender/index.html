<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Space Defender AI</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px #0ff;
            align-items: flex-start;
        }

        .hud-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
            text-align: left;
        }

        .hud-right {
            display: flex;
            flex-direction: column;
            gap: 5px;
            text-align: right;
        }

        #bossTimer {
            color: #f55;
            font-size: 16px;
        }

        .hud-center {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        /* Vertical Arsenal System Styles */
        #arsenal-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0ff;
            border-radius: 10px;
            padding: 10px;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
            display: flex;
            flex-direction: row;
            gap: 10px;
            align-items: center;
        }

        .arsenal-title {
            display: none; /* Hide title to save space */
        }

        .heat-container {
            display: flex;
            flex-direction: column-reverse; /* Bottom up */
            align-items: center;
            height: 200px;
            width: 30px;
        }

        .heat-label {
            font-size: 10px;
            color: #aaa;
            margin-top: 5px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
        }

        .heat-bar-bg {
            width: 12px;
            height: 100%;
            background: #333;
            border: 1px solid #555;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }

        #heat-bar-fill {
            width: 100%;
            height: 0%;
            background: #0f0;
            position: absolute;
            bottom: 0;
            left: 0;
            transition: height 0.1s linear, background-color 0.2s;
        }

        .modules-grid {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .module-icon {
            width: 36px;
            height: 36px;
            border: 1px solid #444;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #444;
            border-radius: 5px;
            position: relative;
            transition: all 0.2s;
        }

        .module-active {
            border-color: #fff;
            color: #fff;
            text-shadow: 0 0 5px currentColor;
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
            box-shadow: 0 0 8px rgba(255,255,255,0.3);
        }
        
        .weapon-active-spread {
            border-color: #0ff;
            color: #0ff;
            box-shadow: 0 0 10px #0ff;
        }
        
        .weapon-active-laser {
            border-color: #0f0;
            color: #0f0;
            box-shadow: 0 0 10px #0f0;
        }

        .module-sub {
            position: absolute;
            bottom: 1px;
            right: 2px;
            font-size: 9px;
            font-weight: bold;
        }

        /* --- */

        .level-up-msg {
            font-size: 40px;
            color: #ff0;
            text-shadow: 0 0 20px #ff0;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .powerup-msg {
            font-size: 24px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            margin-top: 10px;
        }

        .boss-warning {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 50px;
            font-weight: 900;
            color: #f00;
            text-shadow: 0 0 20px #f00;
            animation: blink 0.5s infinite;
            display: none;
            pointer-events: none;
            z-index: 50;
            letter-spacing: 5px;
        }

        @keyframes blink {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(1.05); }
            100% { opacity: 1; transform: scale(1); }
        }

        .hud-bottom {
            pointer-events: auto;
            display: flex;
            justify-content: center;
            padding: 20px;
        }

        #start-screen, #game-over-screen, #tactical-screen, #joke-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 2px solid #0ff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            max-width: 80%;
            min-width: 300px;
            z-index: 100;
        }
        
        #joke-overlay {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .joke-text {
            font-size: 24px;
            color: #0ff;
            font-style: italic;
            line-height: 1.4;
            min-height: 60px;
            white-space: pre-wrap;
        }

        h1 {
            margin: 0 0 10px 0;
            color: #0ff;
            font-size: 40px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        h2 {
            font-size: 24px;
            color: #ff0;
            margin: 10px 0;
        }

        p {
            color: #aaa;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .ai-text {
            color: #bbf;
            font-style: italic;
            border-left: 3px solid #0ff;
            padding-left: 15px;
            margin: 20px 0;
            text-align: left;
            background: rgba(0, 255, 255, 0.05);
            padding: 10px;
            white-space: pre-wrap;
        }

        .mission-stats {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            font-size: 14px;
            color: #888;
        }
        
        .stat-item {
            border: 1px solid #444;
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .stat-val {
            color: #fff;
            font-weight: bold;
        }

        button {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 12px 30px;
            font-size: 16px;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            margin: 5px;
        }

        button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 15px #0ff;
        }

        button:disabled {
            border-color: #555;
            color: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        .sparkle-btn {
            border-color: #f0f;
            color: #f0f;
        }
        
        .sparkle-btn:hover {
            background: #f0f;
            color: #fff;
            box-shadow: 0 0 15px #f0f;
        }
        
        .danger-btn {
            border-color: #f55;
            color: #f55;
            margin-top: 20px;
        }
        
        .danger-btn:hover {
            background: #f55;
            color: #fff;
            box-shadow: 0 0 15px #f55;
        }
        
        .mode-select-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .hidden {
            display: none !important;
        }

        /* Mobile controls hint */
        .mobile-hint {
            display: none;
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .mobile-hint { display: block; }
            h1 { font-size: 28px; }
            #start-screen, #game-over-screen, #joke-overlay { width: 85%; padding: 20px; }
            #arsenal-panel {
                bottom: 20%; /* Move up on mobile */
                left: 10px;
            }
            .boss-warning { font-size: 30px; }
            .mode-select-container { flex-direction: column; gap: 10px; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-left">
                <div id="levelDisplay" style="color: #ff0;">LEVEL: 1</div>
                <div id="scoreDisplay">SCORE: 0</div>
            </div>
            <div class="hud-right">
                <div id="bossTimer">BOSS: 2:00</div>
                <div id="livesDisplay">LIVES: 3</div>
            </div>
        </div>
        
        <!-- Boss Warning Overlay -->
        <div id="bossWarning" class="boss-warning">⚠ WARNING: BOSS DETECTED ⚠</div>

        <!-- Arsenal Panel -->
        <div id="arsenal-panel">
            <div class="heat-container">
                <div class="heat-bar-bg">
                    <div id="heat-bar-fill"></div>
                </div>
                <div class="heat-label">HEAT</div>
            </div>
            <div class="modules-grid">
                <div id="mod-spread" class="module-icon">S <span id="mod-spread-lvl" class="module-sub">0</span></div>
                <div id="mod-laser" class="module-icon">L <span id="mod-laser-lvl" class="module-sub">0</span></div>
                <div id="mod-missile" class="module-icon">M <span id="mod-missile-lvl" class="module-sub">0</span></div>
                <div id="mod-rapid" class="module-icon">R</div>
                <div id="mod-shield" class="module-icon">♥ <span id="mod-shield-lvl" class="module-sub">0</span></div>
            </div>
        </div>

        <div class="hud-center">
            <div id="levelUpMsg" class="level-up-msg">LEVEL UP!</div>
            <div id="powerUpMsg" class="powerup-msg">POWER UP!</div>
        </div>
        <div class="hud-bottom">
            <button id="tacticalBtn" class="sparkle-btn hidden">✨ Tactical Analysis</button>
        </div>
    </div>

    <!-- Modals -->
    <div id="joke-overlay" class="hidden">
        <h2>Critical Error: Pilot Offline</h2>
        <div id="jokeDisplay" class="joke-text"></div>
        <button id="continueBtn" class="sparkle-btn">Re-Initialize Ship</button>
    </div>

    <div id="start-screen">
        <h1>Neon Defender</h1>
        <div id="mission-briefing">
            <p>System Initialized.</p>
        </div>
        <div class="mission-stats hidden" id="mission-modifiers">
            <div class="stat-item">SPD: <span class="stat-val" id="mod-spd">100%</span></div>
            <div class="stat-item">HP: <span class="stat-val" id="mod-hp">100%</span></div>
            <div class="stat-item">SWARM: <span class="stat-val" id="mod-spawn">100%</span></div>
        </div>
        <div class="ai-text" id="mission-text">
            Select Operation Mode...
        </div>
        <button id="genMissionBtn" class="sparkle-btn">✨ Generate Mission</button>
        
        <div class="mode-select-container">
            <button id="startNormalBtn">Normal Mission</button>
            <button id="startBossBtn" style="border-color: #f55; color: #f55;">Boss Rush Mode</button>
        </div>
        
        <p class="mobile-hint">Touch & Drag to Move/Shoot</p>
    </div>

    <div id="tactical-screen" class="hidden">
        <h2>Tactical Computer</h2>
        <div class="ai-text" id="tactical-text">
            Analyzing combat data...
        </div>
        <button id="resumeBtn">Resume Combat</button>
        <button id="abortBtn" class="danger-btn">Abort Mission</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #f0f;">CRITICAL FAILURE</h1>
        <p id="finalScore">Score: 0</p>
        <div class="ai-text" id="analysis-text">
            Uploading black box data...
        </div>
        <button id="restartBtn">Reboot System</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('scoreDisplay');
        const levelEl = document.getElementById('levelDisplay');
        const livesEl = document.getElementById('livesDisplay');
        const levelUpMsg = document.getElementById('levelUpMsg');
        const powerUpMsg = document.getElementById('powerUpMsg');
        const bossWarningEl = document.getElementById('bossWarning');
        const bossTimerEl = document.getElementById('bossTimer');
        
        // Arsenal UI
        const heatBarFill = document.getElementById('heat-bar-fill');
        const modSpread = document.getElementById('mod-spread');
        const modSpreadLvl = document.getElementById('mod-spread-lvl');
        const modLaser = document.getElementById('mod-laser');
        const modLaserLvl = document.getElementById('mod-laser-lvl');
        const modMissile = document.getElementById('mod-missile');
        const modMissileLvl = document.getElementById('mod-missile-lvl');
        const modRapid = document.getElementById('mod-rapid');
        const modShield = document.getElementById('mod-shield');
        const modShieldLvl = document.getElementById('mod-shield-lvl');

        // Screens & Overlays
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const tacticalScreen = document.getElementById('tactical-screen');
        const jokeOverlay = document.getElementById('joke-overlay');
        const jokeEl = document.getElementById('jokeDisplay');

        // Buttons
        const startBtn = null; // Removed old startBtn
        const restartBtn = document.getElementById('restartBtn');
        const genMissionBtn = document.getElementById('genMissionBtn');
        const tacticalBtn = document.getElementById('tacticalBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const continueBtn = document.getElementById('continueBtn');
        const abortBtn = document.getElementById('abortBtn');
        const startNormalBtn = document.getElementById('startNormalBtn');
        const startBossBtn = document.getElementById('startBossBtn');

        // Text Areas
        const finalScoreEl = document.getElementById('finalScore');
        const missionText = document.getElementById('mission-text');
        const analysisText = document.getElementById('analysis-text');
        const tacticalText = document.getElementById('tactical-text');
        
        // Modifiers UI
        const missionModifiersEl = document.getElementById('mission-modifiers');
        const modSpdEl = document.getElementById('mod-spd');
        const modHpEl = document.getElementById('mod-hp');
        const modSpawnEl = document.getElementById('mod-spawn');

        // API Key (Runtime provided)
        const apiKey = "AIzaSyDvcn13K2W83Zx-k7Aa962kS5j6W1cdbW0"; 

        // Game State
        let gameRunning = false;
        let paused = false;
        let score = 0;
        let frames = 0;
        let level = 1;
        let nextLevelScore = 1000;
        let difficultyMultiplier = 1;
        let gameMode = 'normal'; // 'normal' or 'boss_rush'
        
        // FPS Cap Variables
        const FPS = 60;
        const frameInterval = 1000 / FPS;
        let lastFrameTime = 0;
        
        // Boss State
        let currentBoss = null;
        let bossesDefeated = 0;
        let framesSinceLastBoss = 0;
        const BOSS_TIME_LIMIT = 7200; // 2 minutes @ 60fps
        
        // Mission Configuration (Default)
        let missionConfig = {
            enemySpeed: 1.0,
            enemyHealth: 1.0,
            spawnRate: 1.0
        };
        
        // Message Timers
        let levelMsgTimeout;
        let powerUpMsgTimeout;

        // --- GEMINI API INTEGRATION ---

        async function callGemini(prompt, targetElement) {
            targetElement.textContent = "Processing data stream...";
            targetElement.style.opacity = "0.7";
            
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!response.ok) throw new Error('API Uplink Failed');

                const data = await response.json();
                const text = data.candidates[0].content.parts[0].text;
                
                // Typewriter effect
                targetElement.textContent = "";
                targetElement.style.opacity = "1";
                let i = 0;
                const speed = 30;
                function typeWriter() {
                    if (i < text.length) {
                        targetElement.textContent += text.charAt(i);
                        i++;
                        setTimeout(typeWriter, speed);
                    }
                }
                typeWriter();

            } catch (error) {
                console.error(error);
                targetElement.textContent = "Error: Uplink severed. Standard protocols engaged.";
            }
        }

        async function generateMissionProfile() {
            missionText.textContent = "Negotiating Mission Parameters...";
            missionText.style.opacity = "0.7";
            genMissionBtn.disabled = true;

            const prompt = `
                You are a sci-fi game director. Generate a mission profile in JSON format.
                Do not include markdown formatting like \`\`\`json. Just the raw JSON.
                Return this structure:
                {
                    "operationName": "String (Cool Name)",
                    "objective": "String (1 sentence description)",
                    "enemySpeed": Number (0.8 to 1.5),
                    "enemyHealth": Number (0.8 to 1.5),
                    "spawnRate": Number (0.8 to 1.5)
                }
                Vary the stats: Make some fast/weak, some slow/tanky, some swarmy.
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                const data = await response.json();
                let text = data.candidates[0].content.parts[0].text;
                
                // Clean markdown if present
                text = text.replace(/```json/g, '').replace(/```/g, '').trim();
                
                const profile = JSON.parse(text);
                
                // Apply Global State
                missionConfig = {
                    enemySpeed: profile.enemySpeed || 1.0,
                    enemyHealth: profile.enemyHealth || 1.0,
                    spawnRate: profile.spawnRate || 1.0
                };

                // Update UI
                missionText.textContent = `OP: ${profile.operationName}\nOBJ: ${profile.objective}`;
                missionText.style.opacity = "1";
                
                missionModifiersEl.classList.remove('hidden');
                modSpdEl.innerText = Math.round(missionConfig.enemySpeed * 100) + "%";
                modHpEl.innerText = Math.round(missionConfig.enemyHealth * 100) + "%";
                modSpawnEl.innerText = Math.round(missionConfig.spawnRate * 100) + "%";
                
                // Color coding
                modSpdEl.style.color = missionConfig.enemySpeed > 1 ? '#f55' : '#5f5';
                modHpEl.style.color = missionConfig.enemyHealth > 1 ? '#f55' : '#5f5';
                modSpawnEl.style.color = missionConfig.spawnRate > 1 ? '#f55' : '#5f5';

            } catch (e) {
                console.error(e);
                missionText.textContent = "Error: Mission Uplink Failed. Defaulting to standard patrol.";
                missionConfig = { enemySpeed: 1, enemyHealth: 1, spawnRate: 1 };
                missionModifiersEl.classList.add('hidden');
            }
            genMissionBtn.disabled = false;
        }

        genMissionBtn.addEventListener('click', generateMissionProfile);

        tacticalBtn.addEventListener('click', () => {
            if (!gameRunning) return;
            paused = true;
            tacticalScreen.classList.remove('hidden');
            tacticalBtn.classList.add('hidden');
            
            const prompt = `You are a helpful tactical spaceship AI. The player is paused. Current Status: Lives ${player.lives}, Level: ${level}, Score: ${score}. Give one short sentence of tactical advice or encouragement.`;
            callGemini(prompt, tacticalText);
        });

        resumeBtn.addEventListener('click', () => {
            paused = false;
            tacticalScreen.classList.add('hidden');
            tacticalBtn.classList.remove('hidden');
            animate(0); // Pass a dummy time or rely on next rAF call
        });

        abortBtn.addEventListener('click', () => {
            // Reset and go to start screen
            gameRunning = false;
            paused = false;
            tacticalScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            // Hide any other overlays
            jokeOverlay.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            bossWarningEl.style.display = 'none';
        });

        continueBtn.addEventListener('click', () => {
            jokeOverlay.classList.add('hidden');
            paused = false;
            
            if (player.lives <= 0) {
                gameOver();
            } else {
                // Respawn
                player.x = canvas.width / 2 - player.width / 2;
                player.y = canvas.height - 100;
                player.invulnerable = 120; // 2 seconds safety
                animate(0);
            }
        });

        function triggerGameOverAnalysis() {
            const prompt = `You are a sarcastic spaceship computer. The pilot just crashed their ship. Final Score: ${score}. Reached Level: ${level}. Give a one-sentence snarky performance review.`;
            callGemini(prompt, analysisText);
        }

        function triggerDeathComment() {
            paused = true; // Pause Game Loop
            jokeOverlay.classList.remove('hidden');
            
            const prompt = "You are a sarcastic spaceship AI. The pilot just exploded and lost a life. Give a very short (one sentence) roast about their piloting skills or a backhanded compliment. Be witty.";
            callGemini(prompt, jokeEl);
        }

        function updateArsenalUI() {
            if (!player) return;

            // Heat Bar
            const heatPct = Math.min(100, (player.heat / player.maxHeat) * 100);
            heatBarFill.style.height = heatPct + '%';
            
            if (player.hasRapidFire) {
                heatBarFill.style.backgroundColor = '#0ff'; // Blue for infinite
            } else if (player.overheated) {
                heatBarFill.style.backgroundColor = '#f00'; // Red
            } else {
                if (heatPct > 75) {
                    heatBarFill.style.backgroundColor = '#f80';
                } else {
                    heatBarFill.style.backgroundColor = '#0f0';
                }
            }

            // Modules Active State (Weapon Switch)
            const isSpread = player.weaponMode === 'spread';
            const isLaser = player.weaponMode === 'laser';

            // Spread Icon
            modSpread.className = 'module-icon'; // Reset
            if (isSpread) modSpread.classList.add('module-active', 'weapon-active-spread');
            modSpreadLvl.innerText = player.spreadLevel;

            // Laser Icon
            modLaser.className = 'module-icon'; // Reset
            if (isLaser) modLaser.classList.add('module-active', 'weapon-active-laser');
            modLaserLvl.innerText = player.laserLevel;

            // Missile Icon
            modMissile.classList.toggle('module-active', player.missileLevel > 0);
            modMissile.style.borderColor = player.missileLevel > 0 ? '#f0f' : '#444';
            modMissile.style.color = player.missileLevel > 0 ? '#f0f' : '#444';
            modMissileLvl.innerText = player.missileLevel;

            modRapid.classList.toggle('module-active', player.hasRapidFire);
            modRapid.style.borderColor = player.hasRapidFire ? '#fa0' : '#444';
            modRapid.style.color = player.hasRapidFire ? '#fa0' : '#444';

            // Shield Icon
            modShield.classList.toggle('module-active', player.shieldLevel > 0);
            modShield.style.borderColor = player.shieldLevel > 0 ? '#fff' : '#444';
            modShield.style.color = player.shieldLevel > 0 ? '#fff' : '#444';
            modShieldLvl.innerText = player.shieldLevel;
        }

        // --- GAME ENGINE ---

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            Space: false
        };

        const pointer = {
            x: null,
            y: null,
            active: false
        };

        window.addEventListener('keydown', (e) => {
            // Modal Navigation (Space/Enter to continue)
            if (!jokeOverlay.classList.contains('hidden') && (e.code === 'Space' || e.code === 'Enter')) {
                continueBtn.click();
                return; 
            }
            if (!gameOverScreen.classList.contains('hidden') && (e.code === 'Space' || e.code === 'Enter')) {
                restartBtn.click();
                return;
            }

            if (e.code === 'Space') keys.Space = true;
            if (e.key === 'ArrowUp') keys.ArrowUp = true;
            if (e.key === 'ArrowDown') keys.ArrowDown = true;
            if (e.key === 'ArrowLeft') keys.ArrowLeft = true;
            if (e.key === 'ArrowRight') keys.ArrowRight = true;
            if (e.key === 't' || e.key === 'T') tacticalBtn.click();
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') keys.Space = false;
            if (e.key === 'ArrowUp') keys.ArrowUp = false;
            if (e.key === 'ArrowDown') keys.ArrowDown = false;
            if (e.key === 'ArrowLeft') keys.ArrowLeft = false;
            if (e.key === 'ArrowRight') keys.ArrowRight = false;
        });

        window.addEventListener('touchstart', (e) => {
            pointer.active = true;
            pointer.x = e.touches[0].clientX;
            pointer.y = e.touches[0].clientY;
            keys.Space = true; 
        }, {passive: false});

        window.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            if (pointer.active) {
                pointer.x = e.touches[0].clientX;
                pointer.y = e.touches[0].clientY;
            }
        }, {passive: false});

        window.addEventListener('touchend', () => {
            pointer.active = false;
            keys.Space = false;
        });

        // Fixed: Restored missing function to prevent ReferenceError
        function showPowerUpMsg(text, color) {
            powerUpMsg.innerText = text;
            powerUpMsg.style.color = color;
            powerUpMsg.style.textShadow = `0 0 10px ${color}`;
            
            clearTimeout(powerUpMsgTimeout);
            powerUpMsg.style.opacity = 1;
            
            powerUpMsgTimeout = setTimeout(() => {
                powerUpMsg.style.opacity = 0;
            }, 1500);
        }

        // CLASSES
        class Player {
            constructor() {
                this.width = 40;
                this.height = 50; 
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height - 100;
                this.speed = 7;
                this.color = '#0ff';
                this.lives = 3;
                this.lastShot = 0;
                this.shootDelay = 15;
                this.shieldLevel = 0;
                this.invulnerable = 0;
                this.exploding = false;
                this.weaponMode = 'spread';
                this.spreadLevel = 0;
                this.laserLevel = 0;
                this.missileLevel = 0;
                this.heat = 0;
                this.maxHeat = 100;
                this.overheated = false;
                this.overheatTimer = 0;
                this.hasRapidFire = false;
                this.rapidFireTimer = 0;
            }
            draw() {
                if (this.exploding) return;
                if (this.invulnerable > 0 && Math.floor(frames / 4) % 2 === 0) return;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.lineTo(this.x + this.width / 2, this.y + this.height - 10);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.closePath();
                ctx.fill();
                if (this.shieldLevel > 0) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, 40, 0, Math.PI * 2);
                    if (this.shieldLevel === 1) { ctx.strokeStyle = '#0ff'; ctx.fillStyle = 'rgba(0, 255, 255, 0.1)'; }
                    else if (this.shieldLevel === 2) { ctx.strokeStyle = '#00f'; ctx.fillStyle = 'rgba(0, 0, 255, 0.15)'; ctx.lineWidth = 3; }
                    else { ctx.strokeStyle = '#fff'; ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.lineWidth = 4; ctx.shadowBlur = 15; ctx.shadowColor = '#f0f'; }
                    ctx.stroke();
                    ctx.fill();
                    ctx.restore();
                }
                let activeLevel = this.weaponMode === 'spread' ? this.spreadLevel : this.laserLevel;
                let activeColor = this.weaponMode === 'spread' ? '#ff0' : '#0f0';
                if (activeLevel > 0) { ctx.fillStyle = activeColor; ctx.fillRect(this.x - 5, this.y + 20, 5, 10); ctx.fillRect(this.x + this.width, this.y + 20, 5, 10); }
                if (activeLevel > 2) { ctx.fillStyle = activeColor; ctx.fillRect(this.x - 10, this.y + 30, 5, 15); ctx.fillRect(this.x + this.width + 5, this.y + 30, 5, 15); }
                if (activeLevel >= 6) { ctx.fillStyle = '#f0f'; ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 4, 0, Math.PI*2); ctx.fill(); }
                if (Math.random() > 0.5) { ctx.fillStyle = '#f0f'; ctx.beginPath(); ctx.moveTo(this.x + this.width / 2 - 5, this.y + this.height - 5); ctx.lineTo(this.x + this.width / 2 + 5, this.y + this.height - 5); ctx.lineTo(this.x + this.width / 2, this.y + this.height + 15 + Math.random() * 10); ctx.closePath(); ctx.fill(); }
                ctx.shadowBlur = 0;
            }
            update() {
                if (this.exploding) return;
                if (this.hasRapidFire) {
                    this.rapidFireTimer--;
                    if (this.rapidFireTimer <= 0) { this.hasRapidFire = false; showPowerUpMsg("RAPID FIRE ENDED", "#aaa"); }
                }
                if (this.overheated) {
                    this.overheatTimer--;
                    this.heat = (this.overheatTimer / 300) * 100; 
                    if (this.overheatTimer <= 0) { this.overheated = false; this.heat = 0; }
                } else if (!this.hasRapidFire) {
                    if (!keys.Space) { this.heat = Math.max(0, this.heat - 0.5); }
                }
                if (this.invulnerable > 0) this.invulnerable--;
                if (keys.ArrowLeft) this.x -= this.speed;
                if (keys.ArrowRight) this.x += this.speed;
                if (keys.ArrowUp && this.y > 0) this.y -= this.speed;
                if (keys.ArrowDown && this.y + this.height < canvas.height) this.y += this.speed;
                if (this.x + this.width < 0) this.x = canvas.width; else if (this.x > canvas.width) this.x = -this.width;
                if (pointer.active) {
                    const targetX = pointer.x - this.width/2;
                    const targetY = pointer.y - 30; 
                    this.x += (targetX - this.x) * 0.2;
                    this.y += (targetY - this.y) * 0.2;
                }
                const currentShootDelay = this.hasRapidFire ? 5 : this.shootDelay;
                if (keys.Space && (!this.overheated || this.hasRapidFire) && frames - this.lastShot > currentShootDelay) { this.shoot(); this.lastShot = frames; }
                if (this.missileLevel > 0 && frames % 60 === 0 && (enemies.length > 0 || currentBoss)) {
                    let count = Math.max(1, this.missileLevel);
                    for (let i = 0; i < count; i++) { setTimeout(() => { projectiles.push(new HomingMissile(this.x + this.width/2, this.y, -15 + (i * 10))); }, i * 100); }
                }
            }
            shoot() {
                if (!this.hasRapidFire) {
                    this.heat += 6; 
                    if (this.heat >= this.maxHeat) { this.heat = this.maxHeat; this.overheated = true; this.overheatTimer = 300; showPowerUpMsg("OVERHEATED!", "#f00"); }
                } else { this.heat = 0; this.overheated = false; }
                let type = this.weaponMode === 'laser' ? 'laser' : 'normal';
                let cx = this.x + this.width / 2;
                let cy = this.y;
                const spawn = (ox, oy, angle) => projectiles.push(new Projectile(cx + ox, cy + oy, false, type, angle));
                if (type === 'laser') {
                    if (this.laserLevel === 0) spawn(0, 0, 0);
                    else if (this.laserLevel === 1) { spawn(-10, 0, 0); spawn(10, 0, 0); }
                    else if (this.laserLevel === 2) { spawn(-15, 0, 0); spawn(0, -5, 0); spawn(15, 0, 0); }
                    else if (this.laserLevel === 3) { spawn(0, -5, 0); spawn(0, 0, -0.15); spawn(0, 0, 0.15); }
                    else if (this.laserLevel === 4) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.2); spawn(0, 0, 0.2); }
                    else if (this.laserLevel === 5) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.2); spawn(0, 0, 0.2); spawn(0, 5, -1.0); spawn(0, 5, 1.0); }
                    else if (this.laserLevel >= 6) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.2); spawn(0, 0, 0.2); spawn(0, 5, -1.0); spawn(0, 5, 1.0); spawn(0, 10, Math.PI); spawn(0, 8, Math.PI - 0.4); spawn(0, 8, Math.PI + 0.4); }
                } else {
                    if (this.spreadLevel === 0) spawn(0, 0, 0);
                    else if (this.spreadLevel === 1) { spawn(-10, 0, 0); spawn(10, 0, 0); }
                    else if (this.spreadLevel === 2) { spawn(-15, 0, 0); spawn(0, -5, 0); spawn(15, 0, 0); }
                    else if (this.spreadLevel === 3) { spawn(0, -5, 0); spawn(0, 0, -0.2); spawn(0, 0, 0.2); }
                    else if (this.spreadLevel === 4) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.3); spawn(0, 0, 0.3); }
                    else if (this.spreadLevel === 5) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.3); spawn(0, 0, 0.3); spawn(0, 5, -1.4); spawn(0, 5, 1.4); }
                    else if (this.spreadLevel >= 6) { spawn(-10, -5, 0); spawn(10, -5, 0); spawn(0, 0, -0.3); spawn(0, 0, 0.3); spawn(0, 5, -1.5); spawn(0, 5, 1.5); spawn(0, 10, Math.PI); spawn(0, 8, Math.PI - 0.4); spawn(0, 8, Math.PI + 0.4); }
                }
            }
        }

        class Projectile {
            constructor(x, y, isEnemy, type = 'normal', angle = 0) {
                this.x = x; this.y = y; this.isEnemy = isEnemy; this.type = type; this.angle = angle;
                this.radius = isEnemy ? 4 : 3; if (type === 'laser') this.radius = 4;
                this.color = isEnemy ? '#f44' : '#ff0'; if (type === 'laser') this.color = '#0ff';
                this.speed = isEnemy ? 6 : 10; if (type === 'laser') this.speed = 18;
                this.markedForDeletion = false; this.piercing = (type === 'laser');
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                if (this.type === 'laser') { ctx.rotate(this.angle); ctx.fillStyle = this.color; ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.fillRect(-3, -20, 6, 40); }
                else { ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.fill(); }
                ctx.restore();
            }
            update() {
                if (this.isEnemy) { this.y += this.speed; if(this.angle !== 0) this.x += Math.sin(this.angle) * this.speed; if (this.y > canvas.height) this.markedForDeletion = true; }
                else { this.x += Math.sin(this.angle) * this.speed; this.y -= Math.cos(this.angle) * this.speed; if (this.y < 0 || this.x < 0 || this.x > canvas.width || this.y > canvas.height) this.markedForDeletion = true; }
            }
        }

        class HomingMissile extends Projectile {
            constructor(x, y, initialOffset = 0) {
                super(x + initialOffset, y, false, 'missile', 0);
                this.color = '#f0f'; this.speed = 5; this.target = null; this.radius = 5; this.turnSpeed = 0.08; this.life = 120;
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(4, 4); ctx.lineTo(0, 2); ctx.lineTo(-4, 4); ctx.closePath(); ctx.fill();
                if (frames % 4 === 0) particles.push(new Particle(this.x, this.y + 5, '#aaa')); ctx.restore();
            }
            update() {
                this.life--; if (this.life <= 0) { this.markedForDeletion = true; createBlast(this.x, this.y); createExplosion(this.x, this.y, '#aaa', 5); return; }
                if (!this.target || this.target.markedForDeletion) {
                    if (currentBoss) this.target = currentBoss;
                    else { let minDist = Infinity; let closest = null; enemies.forEach(e => { let d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minDist) { minDist = d; closest = e; } }); this.target = closest; }
                }
                if (this.target) { this.x += (this.target.x + (this.target.width?this.target.width/2:0) - this.x) * this.turnSpeed; this.y += (this.target.y + (this.target.height?this.target.height/2:0) - this.y) * this.turnSpeed; }
                else { this.y -= this.speed; }
                if (this.y < 0 || this.y > canvas.height) this.markedForDeletion = true;
            }
        }

        class Boss {
            constructor(difficulty) {
                this.width = 120; this.height = 80; this.x = canvas.width / 2 - this.width / 2; this.y = -150; this.targetY = 80;
                this.hp = 100 + (difficulty * 50); this.maxHp = this.hp; this.state = 'entering';
                this.moveTimer = 0; this.attackTimer = 0; 
                this.speed = 1.5;
                this.attackInterval = 120; 
                this.minionSpawnInterval = 600;
                this.minionSpawnCount = 2;

                if (gameMode === 'boss_rush') {
                    if (difficulty === 0) {
                        this.speed = 1.5 * 0.25; 
                        this.attackInterval = 270; 
                        this.minionSpawnInterval = 300;
                        this.minionSpawnCount = 1;
                    } else {
                        this.speed = 1.5 + (difficulty * 0.1); 
                        this.attackInterval = Math.max(60, 120 - (difficulty * 5));
                        this.minionSpawnInterval = Math.max(200, 600 - (difficulty * 20));
                        this.minionSpawnCount = 2 + Math.floor(difficulty / 3);
                    }
                }
                this.color = '#f00'; this.markedForDeletion = false;
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = this.color; ctx.shadowBlur = 20; ctx.shadowColor = '#f00';
                ctx.beginPath(); ctx.moveTo(this.width/2, this.height); ctx.lineTo(this.width, 0); ctx.lineTo(this.width/2, 20); ctx.lineTo(0, 0); ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.width/2, 40, 15, 0, Math.PI*2); ctx.fill(); ctx.restore();
                const barW = 300; const barH = 20; const barX = (canvas.width - barW) / 2; const barY = 20;
                ctx.fillStyle = '#333'; ctx.fillRect(barX, barY, barW, barH);
                ctx.fillStyle = '#f00'; ctx.fillRect(barX, barY, barW * (this.hp / this.maxHp), barH);
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(barX, barY, barW, barH);
                ctx.fillStyle = '#fff'; ctx.font = '16px Courier New'; ctx.fillText("OMEGA CLASS THREAT", barX + 60, barY + 16);
            }
            update() {
                if (this.state === 'entering') { this.y += 2; if (this.y >= this.targetY) this.state = 'idle'; }
                else if (this.state === 'idle') {
                    this.x += Math.sin(frames * 0.02) * this.speed * 2;
                    this.attackTimer++;
                    if (this.attackTimer > this.attackInterval) { this.attack(); this.attackTimer = 0; }
                    if (frames % this.minionSpawnInterval === 0) { 
                        for(let i=0; i < this.minionSpawnCount; i++) enemies.push(new SwarmEnemy()); 
                    }
                }
            }
            attack() {
                const rand = Math.random();
                if (rand < 0.4) { for(let i=-2; i<=2; i++) projectiles.push(new Projectile(this.x + this.width/2, this.y + this.height, true, 'normal', i*0.2)); }
                else { let p = new Projectile(this.x + this.width/2, this.y + this.height, true, 'laser', 0); p.radius = 8; p.speed = 8; projectiles.push(p); }
            }
        }

        class PowerUp {
            constructor(x, y) {
                this.x = x; this.y = y; this.radius = 15; this.speed = 3; this.markedForDeletion = false;
                const rand = Math.random();
                if (rand < 0.3) { this.type = 'S'; this.color = '#0ff'; this.text = 'S'; }
                else if (rand < 0.5) { this.type = 'M'; this.color = '#f0f'; this.text = 'M'; }
                else if (rand < 0.65) { this.type = 'L'; this.color = '#0f0'; this.text = 'L'; }
                else if (rand < 0.85) { this.type = 'R'; this.color = '#fa0'; this.text = 'R'; }
                else { this.type = 'H'; this.color = '#fff'; this.text = '♥'; }
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                let scale = 1 + Math.sin(frames * 0.1) * 0.1; ctx.scale(scale, scale);
                ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = this.color; ctx.stroke();
                ctx.fillStyle = this.color; ctx.font = "bold 16px Courier New"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(this.text, 0, 1); ctx.restore();
            }
            update() { this.y += this.speed; if (this.y > canvas.height) this.markedForDeletion = true; }
        }

        class Enemy { constructor() { this.markedForDeletion = false; } draw() {} update() {} dropPowerUp() { if (Math.random() < 0.15) powerUps.push(new PowerUp(this.x, this.y)); } }
        class SwarmEnemy extends Enemy {
            constructor() { super(); this.radius = 15 + Math.random() * 15; this.x = Math.random() * (canvas.width - this.radius * 2) + this.radius; this.y = -this.radius; this.color = `hsl(${Math.random() * 60 + 300}, 100%, 50%)`; this.speed = ((Math.random() * 2 + 1) * difficultyMultiplier) * missionConfig.enemySpeed; this.angle = 0; this.spinSpeed = Math.random() * 0.1 - 0.05; this.health = Math.max(1, Math.floor((this.radius / 8) * missionConfig.enemyHealth)); this.points = 100; }
            draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.beginPath(); for (let i = 0; i < 6; i++) ctx.lineTo(this.radius * Math.cos(i * Math.PI / 3), this.radius * Math.sin(i * Math.PI / 3)); ctx.closePath(); ctx.stroke(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, this.radius/3, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
            update() { this.y += this.speed; this.angle += this.spinSpeed; if (this.y - this.radius > canvas.height) this.markedForDeletion = true; }
        }
        class InterceptorEnemy extends Enemy {
            constructor() { super(); this.width = 30; this.height = 30; this.x = Math.random() * (canvas.width - this.width); this.y = -this.height; this.speed = ((3 + Math.random()) * difficultyMultiplier) * missionConfig.enemySpeed; this.color = '#fa0'; this.health = Math.max(1, Math.floor(2 * missionConfig.enemyHealth)); this.points = 200; this.initialX = this.x; this.wobbleSpeed = Math.random() * 0.05 + 0.02; this.wobbleDist = 50; }
            draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.beginPath(); ctx.moveTo(-15, -15); ctx.lineTo(15, -15); ctx.lineTo(0, 15); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(0, -15, 5, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
            update() { this.y += this.speed; this.x = this.initialX + Math.sin(frames * this.wobbleSpeed) * this.wobbleDist; if (this.y > canvas.height) this.markedForDeletion = true; if (Math.random() < 0.015) projectiles.push(new Projectile(this.x, this.y + 10, true)); }
        }
        class Particle {
            constructor(x, y, color) { this.x = x; this.y = y; this.radius = Math.random() * 3; this.color = color; this.velocity = { x: (Math.random() - 0.5) * 8, y: (Math.random() - 0.5) * 8 }; this.alpha = 1; this.markedForDeletion = false; }
            draw() { ctx.save(); ctx.globalAlpha = this.alpha; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill(); ctx.restore(); }
            update() { this.x += this.velocity.x; this.y += this.velocity.y; this.alpha -= 0.02; if (this.alpha <= 0) this.markedForDeletion = true; }
        }
        class Star {
            constructor() { this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.size = Math.random() * 2; this.speed = Math.random() * 3 + 0.5; }
            draw() { ctx.fillStyle = '#fff'; ctx.globalAlpha = Math.random() * 0.5 + 0.3; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1.0; }
            update() { this.y += this.speed; if (this.y > canvas.height) { this.y = 0; this.x = Math.random() * canvas.width; } }
        }

        // Global Arrays
        let player; let projectiles = []; let enemies = []; let particles = []; let stars = []; let powerUps = [];

        function init(mode) {
            if (jokeOverlay) jokeOverlay.classList.add('hidden');
            levelUpMsg.style.opacity = "0"; clearTimeout(levelMsgTimeout);
            gameMode = mode; player = new Player(); projectiles = []; enemies = []; particles = []; stars = []; powerUps = [];
            score = 0; level = 1; nextLevelScore = 1000; frames = 0; difficultyMultiplier = 1; paused = false;
            currentBoss = null; bossesDefeated = 0; framesSinceLastBoss = 0;
            for(let i=0; i<100; i++) stars.push(new Star());
            scoreEl.innerText = "SCORE: " + score; levelEl.innerText = "LEVEL: " + level; livesEl.innerText = "LIVES: 3"; livesEl.style.color = '#fff';
            gameRunning = true; startScreen.classList.add('hidden'); gameOverScreen.classList.add('hidden'); tacticalBtn.classList.remove('hidden');
            animate(0); // Pass dummy time
        }

        startNormalBtn.addEventListener('click', () => init('normal'));
        startBossBtn.addEventListener('click', () => init('boss_rush'));
        restartBtn.addEventListener('click', () => init(gameMode));

        function initBoss() {
            if (currentBoss) return; 
            bossWarningEl.style.display = 'block';
            setTimeout(() => { bossWarningEl.style.display = 'none'; currentBoss = new Boss(bossesDefeated); }, 3000);
        }

        function spawnEnemies() {
            if (gameMode === 'boss_rush') { if (!currentBoss && bossWarningEl.style.display !== 'block') { if (frames % 120 === 0) initBoss(); } return; }
            if (currentBoss || bossWarningEl.style.display === 'block') return;
            let spawnRate = Math.max(20, 60 - (level * 5));
            let moddedRate = Math.max(10, Math.floor(spawnRate / missionConfig.spawnRate));
            if (frames % moddedRate === 0) {
                let rand = Math.random();
                let interceptorChance = (level > 1) ? Math.min(0.5, (level - 1) * 0.15) : 0;
                if (rand < interceptorChance) enemies.push(new InterceptorEnemy()); else enemies.push(new SwarmEnemy());
            }
        }

        function checkLevelUp() {
            if (gameMode === 'normal') {
                if (score >= nextLevelScore) {
                    level++; nextLevelScore += 1000 + (level * 500); difficultyMultiplier += 0.2; levelEl.innerText = "LEVEL: " + level;
                    clearTimeout(levelMsgTimeout); levelUpMsg.style.opacity = "1"; levelMsgTimeout = setTimeout(() => { levelUpMsg.style.opacity = "0"; }, 2000);
                    if (level % 5 === 0) initBoss();
                }
            } else { levelEl.innerText = "BOSS: " + (bossesDefeated + 1); }
        }

        function createExplosion(x, y, color, count = 20) { for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color)); }

        function createBlast(x, y) {
            for (let i = 0; i < 20; i++) { const angle = (Math.PI * 2 / 20) * i; particles.push(new Particle(x, y, '#0ff')); particles[particles.length-1].velocity.x = Math.cos(angle) * 5; particles[particles.length-1].velocity.y = Math.sin(angle) * 5; }
            const blastRadius = 80; const damage = 1; 
            enemies.forEach((enemy) => {
                const dist = Math.hypot(x - enemy.x, y - enemy.y);
                if (dist < blastRadius + (enemy.radius || 20)) {
                    enemy.health -= damage; createExplosion(enemy.x, enemy.y, '#0ff', 5);
                    if (enemy.health <= 0) {
                        createExplosion(enemy.x, enemy.y, enemy.color, 20); enemy.dropPowerUp();
                        setTimeout(() => { const idx = enemies.indexOf(enemy); if (idx > -1) { enemies.splice(idx, 1); score += enemy.points; scoreEl.innerText = "SCORE: " + score; checkLevelUp(); } }, 0);
                    }
                }
            });
            if (currentBoss && currentBoss.state !== 'entering') {
                const bx = currentBoss.x + currentBoss.width/2; const by = currentBoss.y + currentBoss.height/2;
                const dist = Math.hypot(x - bx, y - by);
                if (dist < blastRadius + 60) {
                    currentBoss.hp -= damage; createExplosion(bx, by, '#fff', 5);
                    if (currentBoss.hp <= 0) {
                         createExplosion(currentBoss.x + currentBoss.width/2, currentBoss.y + currentBoss.height/2, '#f00', 100);
                         for(let k=0; k<5; k++) powerUps.push(new PowerUp(currentBoss.x + Math.random()*100, currentBoss.y + Math.random()*50));
                         currentBoss = null; bossesDefeated++; framesSinceLastBoss = 0; score += 5000; scoreEl.innerText = "SCORE: " + score;
                         if(gameMode === 'boss_rush') difficultyMultiplier += 0.5;
                    }
                }
            }
        }

        function playerHit() {
            if (player.invulnerable > 0) return;
            if (player.shieldLevel > 0) { player.shieldLevel--; createExplosion(player.x + player.width/2, player.y + player.height/2, '#0ff', 30); player.invulnerable = 60; showPowerUpMsg("SHIELD -" + (player.shieldLevel+1), "#f00"); return; }
            player.lives--; livesEl.innerText = "LIVES: " + player.lives; livesEl.style.color = '#f00';
            createExplosion(player.x + player.width/2, player.y + player.height/2, '#f0f', 80);
            enemies = []; projectiles = [];
            player.spreadLevel = 0; player.laserLevel = 0; player.missileLevel = 0; player.weaponMode = 'spread'; player.hasRapidFire = false; player.heat = 0; player.overheated = false;
            player.x = -1000; player.exploding = true; 
            setTimeout(() => {
                player.exploding = false;
                if (currentBoss && player.lives > 0) { player.x = canvas.width / 2 - player.width / 2; player.y = canvas.height - 100; player.invulnerable = 120; }
                else { triggerDeathComment(); }
            }, 1500);
        }

        function checkCollisions() {
            if (player.exploding) return; 
            projectiles.forEach((projectile, pIndex) => {
                if (projectile.isEnemy) {
                    const dist = Math.hypot(projectile.x - (player.x + player.width/2), projectile.y - (player.y + player.height/2));
                    if (dist < 20) { playerHit(); setTimeout(() => projectiles.splice(pIndex, 1), 0); }
                } else {
                    let hit = false;
                    enemies.forEach((enemy, eIndex) => {
                        if(hit) return; 
                        let hitRadius = enemy.radius || 20; const dist = Math.hypot(projectile.x - enemy.x, projectile.y - enemy.y);
                        if (dist - hitRadius - projectile.radius < 1) {
                            hit = true; enemy.health--;
                            if (projectile.type === 'missile') createExplosion(projectile.x, projectile.y, '#f0f', 15); else createExplosion(projectile.x, projectile.y, '#ff0', 5);
                            if (!projectile.piercing) { setTimeout(() => projectiles.splice(pIndex, 1), 0); if (projectile.type === 'missile') createBlast(projectile.x, projectile.y); } else { createExplosion(projectile.x, projectile.y, '#0ff', 5); }
                            if (enemy.health <= 0) { createExplosion(enemy.x, enemy.y, enemy.color, 20); enemy.dropPowerUp(); setTimeout(() => enemies.splice(eIndex, 1), 0); score += enemy.points; scoreEl.innerText = "SCORE: " + score; checkLevelUp(); }
                        }
                    });
                    if (!hit && currentBoss && currentBoss.state !== 'entering') {
                        if (projectile.x > currentBoss.x && projectile.x < currentBoss.x + currentBoss.width && projectile.y > currentBoss.y && projectile.y < currentBoss.y + currentBoss.height) {
                            hit = true; currentBoss.hp--; createExplosion(projectile.x, projectile.y, '#fff', 5);
                            if (!projectile.piercing) { setTimeout(() => projectiles.splice(pIndex, 1), 0); if (projectile.type === 'missile') createBlast(projectile.x, projectile.y); }
                            
                            // Fixed: Check if currentBoss exists before accessing properties to prevent crash on missile kill
                            if (currentBoss && currentBoss.hp <= 0) { 
                                createExplosion(currentBoss.x + currentBoss.width/2, currentBoss.y + currentBoss.height/2, '#f00', 100); 
                                for(let k=0; k<5; k++) powerUps.push(new PowerUp(currentBoss.x + Math.random()*100, currentBoss.y + Math.random()*50)); 
                                currentBoss = null; bossesDefeated++; framesSinceLastBoss = 0; score += 5000; scoreEl.innerText = "SCORE: " + score; 
                                if(gameMode === 'boss_rush') difficultyMultiplier += 0.5; 
                            }
                        }
                    }
                }
            });
            enemies.forEach((enemy, index) => { if (enemy.x > player.x && enemy.x < player.x + player.width && enemy.y > player.y && enemy.y < player.y + player.height) { playerHit(); createExplosion(enemy.x, enemy.y, '#f00', 30); enemies.splice(index, 1); } });
            
            // NEW: Boss Body Collision Check
            if (currentBoss && currentBoss.state !== 'entering') {
                if (player.x < currentBoss.x + currentBoss.width &&
                    player.x + player.width > currentBoss.x &&
                    player.y < currentBoss.y + currentBoss.height &&
                    player.y + player.height > currentBoss.y) {
                    playerHit();
                }
            }

            powerUps.forEach((pu, index) => {
                const dist = Math.hypot(pu.x - (player.x + player.width/2), pu.y - (player.y + player.height/2));
                if (dist < 30) {
                    if (pu.type === 'S') { if (player.weaponMode !== 'spread') { player.weaponMode = 'spread'; showPowerUpMsg("SPREAD MODE", "#0ff"); } else { player.spreadLevel = Math.min(6, player.spreadLevel + 1); showPowerUpMsg("SPREAD UP!", "#0ff"); } }
                    else if (pu.type === 'M') { player.missileLevel = Math.min(6, player.missileLevel + 1); showPowerUpMsg("MISSILE LVL " + player.missileLevel, "#f0f"); }
                    else if (pu.type === 'L') { if (player.weaponMode !== 'laser') { player.weaponMode = 'laser'; showPowerUpMsg("LASER MODE", "#0f0"); } else { player.laserLevel = Math.min(6, player.laserLevel + 1); showPowerUpMsg("LASER UP!", "#0f0"); } }
                    else if (pu.type === 'R') { player.hasRapidFire = true; player.rapidFireTimer = 300; player.overheated = false; player.heat = 0; showPowerUpMsg("RAPID FIRE (5s)", "#fa0"); }
                    else if (pu.type === 'H') { player.shieldLevel = Math.min(3, player.shieldLevel + 1); showPowerUpMsg("SHIELD LVL " + player.shieldLevel, "#fff"); }
                    powerUps.splice(index, 1);
                }
            });
        }

        function gameOver() { gameRunning = false; gameOverScreen.classList.remove('hidden'); tacticalBtn.classList.add('hidden'); finalScoreEl.innerText = "Score: " + score; triggerGameOverAnalysis(); }

        function animate(timestamp) {
            if (!gameRunning || paused) return;
            requestAnimationFrame(animate);

            if (!lastFrameTime) lastFrameTime = timestamp;
            const elapsed = timestamp - lastFrameTime;

            if (elapsed > frameInterval) {
                lastFrameTime = timestamp - (elapsed % frameInterval);

                ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                stars.forEach(star => { star.update(); star.draw(); });
                player.update(); player.draw(); updateArsenalUI();
                if (currentBoss) { currentBoss.update(); currentBoss.draw(); bossTimerEl.innerText = "BOSS: ACTIVE"; bossTimerEl.style.color = "#f00"; }
                else { 
                    if (gameMode === 'normal') { framesSinceLastBoss++; let timeUntilBoss = Math.max(0, BOSS_TIME_LIMIT - framesSinceLastBoss); let seconds = Math.floor(timeUntilBoss / 60); let mins = Math.floor(seconds / 60); let secs = seconds % 60; bossTimerEl.innerText = `BOSS: ${mins}:${secs < 10 ? '0' : ''}${secs}`; bossTimerEl.style.color = "#fff"; if (framesSinceLastBoss > BOSS_TIME_LIMIT) { initBoss(); framesSinceLastBoss = 0; } }
                    else { bossTimerEl.innerText = "BOSS RUSH"; bossTimerEl.style.color = "#f55"; }
                }
                powerUps.forEach((pu, index) => { pu.update(); pu.draw(); if (pu.markedForDeletion) powerUps.splice(index, 1); });
                projectiles.forEach((projectile, index) => { projectile.update(); projectile.draw(); if (projectile.markedForDeletion) projectiles.splice(index, 1); });
                enemies.forEach((enemy, index) => { enemy.update(); enemy.draw(); if (enemy.markedForDeletion) enemies.splice(index, 1); });
                particles.forEach((particle, index) => { particle.update(); particle.draw(); if (particle.markedForDeletion) particles.splice(index, 1); });
                if (!player.exploding) spawnEnemies();
                checkCollisions();
                frames++;
            }
        }

        // Removed startBtn event listener to fix error
        startNormalBtn.addEventListener('click', () => init('normal'));
        startBossBtn.addEventListener('click', () => init('boss_rush'));
        restartBtn.addEventListener('click', () => init(gameMode));

        // Pre-load a mission for flavor
        window.addEventListener('load', () => {
             const prompt = "Generate a very short, cool sci-fi operation name (e.g., Operation: Red Dawn). 4 words max.";
             callGemini(prompt, missionText);
        });

    </script>
</body>
</html>